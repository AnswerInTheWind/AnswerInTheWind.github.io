<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LoRaWAN_stack移植笔记(一)--RF硬件相关]]></title>
      <url>http://yoursite.com/2016/10/11/LoRaWAN_stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0(%E4%B8%80)_RF%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="和硬件相关的问题"><a href="#和硬件相关的问题" class="headerlink" title="和硬件相关的问题"></a>和硬件相关的问题</h2><h3 id="TCXO-的使用"><a href="#TCXO-的使用" class="headerlink" title="TCXO 的使用"></a>TCXO 的使用</h3><p>根据SX1276数据手册，<br><img src="../../../../uploads/LoRaWAN_STM32/REGTCXO.png" alt=""></p>
<ul>
<li><p>如果使用TCXO,则需要配置RegTcxo寄存器为0x19,代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276SetTcxoConfig</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//此函数为自定义的</span></span></div><div class="line">&#123;</div><div class="line">  SX1276Write( REG_TCXO, <span class="number">0x19</span> ); <span class="comment">//设置TCXO  </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在初始化中调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276Init</span><span class="params">( RadioEvents_t *events )</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	SX1276SetTcxoConfig();</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>否则配置为0x09,因为芯片上电默认不使用TCXO，即上电寄存器值即为0x09,所以无需配置</p>
</li>
</ul>
<h3 id="PA-BOOST-引脚的使用"><a href="#PA-BOOST-引脚的使用" class="headerlink" title="PA_BOOST 引脚的使用"></a>PA_BOOST 引脚的使用</h3><p>根据sx1276 数据手册<br><img src="../../../../uploads/LoRaWAN_STM32/REGPACONFIG.png" alt=""></p>
<ul>
<li>如果使用PA_BOOST作为RF输出，则需要配置PaSelect脚为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276SetTxConfig</span><span class="params">(......)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	paConfig = ( paConfig &amp; RF_PACONFIG_PASELECT_MASK ) | SX1276GetPaSelect( SX1276.Settings.Channel );<span class="comment">//选择是否使用PA_BOOST引脚</span></div><div class="line">	...</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//根据具体的电路图不一样，此函数也会币一样，比如低频使用PA_BOOST，高频使用RFO_HF，则函数体如下</span></div><div class="line"><span class="keyword">uint8_t</span> SX1276GetPaSelect( <span class="keyword">uint32_t</span> channel )</div><div class="line">&#123;</div><div class="line">	<span class="comment">//如果是低频的，使用PA_BOOST，高频使用RFO_HF</span></div><div class="line">    <span class="keyword">if</span>( channel &lt; RF_MID_BAND_THRESH )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_PABOOST;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_RFO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果高低频都使用PA_BOOST，则函数体如下</span></div><div class="line"><span class="keyword">uint8_t</span> SX1276GetPaSelect( <span class="keyword">uint32_t</span> channel )</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> RF_PACONFIG_PASELECT_PABOOST; </div><div class="line">&#125;</div><div class="line"><span class="comment">//如果高频使用PA_BOOST，低频使用RFO_LF，则函数体如下</span></div><div class="line"><span class="keyword">uint8_t</span> SX1276GetPaSelect( <span class="keyword">uint32_t</span> channel )</div><div class="line">&#123;</div><div class="line">	<span class="comment">//如果是高频的，使用PA_BOOST，低频使用RFO_LF</span></div><div class="line">    <span class="keyword">if</span>( channel &gt; RF_MID_BAND_THRESH )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_PABOOST;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_RFO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line">* RegPaConfig</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_PACONFIG_PASELECT_MASK                   0x7F</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_PACONFIG_PASELECT_PABOOST                0x80</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_PACONFIG_PASELECT_RFO                    0x00 <span class="comment">// Default</span></span></div></pre></td></tr></table></figure>
<ul>
<li>否则为0</li>
</ul>
<h3 id="RXTX-switch-接收和发送的天线电路的切换"><a href="#RXTX-switch-接收和发送的天线电路的切换" class="headerlink" title="RXTX switch(接收和发送的天线电路的切换)"></a>RXTX switch(接收和发送的天线电路的切换)</h3><p><img src="../../../../uploads/LoRaWAN_STM32/TXRX.png" alt=""><br>在图中可以看到，射频输入和射频输出是不一样的电路，但是用的是一个天线，所以用到了一个射频电路切换的芯片。<br>在程序中，需要做的就是控制FEM_CPS脚，在RX和TX时进行RF1(RFI)和RF2(RFO)的切换。<br>由于在设计中兼容高低频，并且使用两个引脚分别控制高频和低频部分的射频部分输入输出的切换，所以在实际使用中需要控制两个引脚。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276SetAntSw</span><span class="params">( <span class="keyword">uint8_t</span> rxTx )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( rxTx != <span class="number">0</span> ) <span class="comment">// 1: TX, 0: RX</span></div><div class="line">    &#123;</div><div class="line">        GpioWrite( &amp;AntSwitchLf, <span class="number">0</span> );<span class="comment">//切换到低频发射电路</span></div><div class="line">        GpioWrite( &amp;AntSwitchHf, <span class="number">1</span> );<span class="comment">//切换到高频发射电路</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        GpioWrite( &amp;AntSwitchLf, <span class="number">1</span> );<span class="comment">//切换到低频接收电路</span></div><div class="line">        GpioWrite( &amp;AntSwitchHf, <span class="number">0</span> );<span class="comment">//切换到高频接收电路 </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果只有高频或者低频一个部分，上面的代码只要保留相应的部分即可</p>
<h3 id="RTC-相关的问题"><a href="#RTC-相关的问题" class="headerlink" title="RTC 相关的问题"></a>RTC 相关的问题</h3><p>由于原厂例程中使用的是32.768KHz的LSE给RTC提供时钟，而在本设计中，RTC使用的是LSI，所以，此处需要注意，<br>LSE的频率为32.768Khz，</p>
<p>根据Fck_spre = Frtcclk/(PREDIV_S+1)/(PREDIV_A+1)<br>例程中RTC的工作频率为32.778/(3+1)/(3+1) = 2.048Khz,</p>
<p>而内部晶振的频率约为37Khz，故PRVEDIV_S和PREDIV_A的值需要改变。</p>
<pre><code>37/2.048 ~= 18；
数据手册里面有这样一句话：    
Note: When both prescalers are used, it is recommended to configure the 
    asynchronous prescaler to a high value to minimize consumption.
所以：18 = 9*2；故设置PREDIV_A = 8，PREDIV_S = 1;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32时钟配置--系统时钟、RTC时钟、IWDG时钟]]></title>
      <url>http://yoursite.com/2016/10/11/STM32%E6%97%B6%E9%92%9F%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="stm32L0x1的时钟分类"><a href="#stm32L0x1的时钟分类" class="headerlink" title="stm32L0x1的时钟分类"></a>stm32L0x1的时钟分类</h1><p><img src="../../../../uploads/LoRaWAN_STM32/STM32_OSC.png" alt=""><br>先给大家推荐一个软件STM32CubeMX，上面的那张关于时钟的图就是从这个软件中截图得来的，这个软件还可以查看配置的时钟情况以及时钟树，挺方便的。</p>
<p>从图上，可以看出，STM32的始终源一共有HSE、HSI、LSE、LSI、MSI、PLL六种，<br>其中</p>
<ul>
<li>HSE是外部的高速晶振，可以直接使用或者通过PLL倍频,最终输出不能超过32Mhz</li>
<li>HSI是内部的高速RC振荡器，频率为16Mhz，可以直接使用或者通过PLL倍频,最终输出不能超过32Mhz</li>
<li>LSE是外部的低速晶振，可以用于RTC或者IWDG，频率为32.768KH在</li>
<li>LSI是内部的低速RC振荡器，频率约为37KHz</li>
<li>MSI是内部的RC振荡器，其频率编程可调</li>
<li>PLL是一个锁相环，可以将HSE或HSI倍频之后再给系统提供时钟。</li>
</ul>
<p>其中注意的是，内部时钟的精度都比较差,在对时钟要求比较高的场合,建议使用外部晶振</p>
<h2 id="系统时钟源"><a href="#系统时钟源" class="headerlink" title="系统时钟源"></a>系统时钟源</h2><p><img src="../../../../uploads/LoRaWAN_STM32/STM32_OSC_SYSTEM.png" alt=""><br>从图中可以看到，系统时钟的选择有</p>
<ul>
<li>MSI(65.536 kHz, 131.072 kHz, 262.144 kHz, 524.288 kHz, 1.048 MHz,<br>2.097 MHz (default value) and 4.194 MHz)</li>
<li>HSI(16,16/4)</li>
<li>HSE(1-24MHz)</li>
<li>PLLCLK(HSE/HSI倍频锁相环)</li>
</ul>
<p>其中PLLCLK是比较常用的一种，可以将HSE或HSI(HSI/4)倍频，然后再给主系统提供时钟。<br>其计算公式为PLLCLK_OUT = (PLLCLK_SOURCE * PLLMUL / PLLDIV);</p>
<p>例如要给系统提供32MHz的晶振，可以</p>
<ul>
<li>HSI(16) * 4(PLLMUL) / 2(PLLDIV)</li>
<li>HSE(12) * 8(PLLMUL) / 3(PLLDIV)</li>
</ul>
<p>以上两种方法只是举个例子，倍频的方法并不是固定的。</p>
<p>注意，实际使用中，这四个时钟源只能同时选择一个，不能同时选择多个。</p>
<h2 id="RTC时钟源-IWDG-时钟源"><a href="#RTC时钟源-IWDG-时钟源" class="headerlink" title="RTC时钟源  IWDG 时钟源"></a>RTC时钟源  IWDG 时钟源</h2><p><img src="../../../../uploads/LoRaWAN_STM32/STM32_OSC_RTC.png" alt=""></p>
<p>从图中可以看到，IWDG只能使用LSI提供时钟源<br>而RTC可以使用HSE/32(数据手册上查看得来，软件存在明显错误)、LSE、LSI提供时钟源,其中LSE 的频率为32.768KHz，LSI的频率为37KHz。</p>
<p>具体的RTC和IWDG的工作时钟还要进行分频。<br>RTC的工作时钟的计算方法为：Fck_spre = Frtcclk/(PREDIV_S+1)/(PREDIV_A+1);</p>
<p>例如Frtcclk(时钟源频率)为32.768Khz的LSE，PREDIV_S = 3， PREDIV_A =3,则Fck_spre(工作频率) = 32.768/(3+1)/(3+1) = 2.048KHz<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RtcInit</span><span class="params">( <span class="keyword">void</span> )</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	RtcHandle.Init.AsynchPrediv = <span class="number">3</span>;</div><div class="line">    RtcHandle.Init.SynchPrediv = <span class="number">3</span>;	</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line"> * RTC Time base in ms</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_DURATION                     0.48828125      <span class="comment">// 1 tick every 488us</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_PER_MS                       2.048           <span class="comment">// 1/2.048 = tick duration in ms</span></span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN源码阅读笔记————RTC闹钟链表的实现]]></title>
      <url>http://yoursite.com/2016/10/10/semtech_LoRaWAN_timer/</url>
      <content type="html"><![CDATA[<p>近日在阅读semtech的<a href="https://github.com/Lora-net/LoRaMac-node" target="_blank" rel="external">Lora-net/LoRaMac-node</a>。此代码是LoRaWAN MAC层的node段的代码。</p>
<p>此代码中构建了一个定时器链表，此链表构建得非常的巧妙。<br>通过对源码的阅读，明白了其底层的实现原理，现在讲解一下，和大家分享。</p>
<p>此定时器链表底层使用的是RTC的闹钟(Alarm)机制(将日历时间转换成时间戳时间)，而非使用一个定时器产生一个固定的定时(比如1ms)，然后定时刷新整个链表。</p>
<p>用rtc的方法相比较嘀嗒定时器定时的方法，工作效率会明显提升，并不会因为链表中定时器数目的增加使得花费在刷新定时器上的时间增加，因为不需要遍历整个链表。但代码的实现难度会较高</p>
<p>假如程序刚开始执行，而且定时器链表为空，此时有４个定时事件需要放入链表，分别为　A 10ms B 30ms C 20ms D 40ms，</p>
<p>RTC闹钟链表：<br>其存储的结果会是这样:</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>C</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>10</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>而嘀嗒定时链表：<br>其存储的结果会是这样:</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>30</td>
</tr>
<tr>
<td>C</td>
<td>20</td>
</tr>
<tr>
<td>D</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>当时间过了5ms，RTC闹钟链表中存储的数据并不会发生任何变化，因为它是以RTC的闹钟来作为刷新依据的，而嘀嗒定时链表中的数据就全发生了变化<br>嘀嗒定时链表 变化得到情况如下：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>B</td>
<td>25</td>
</tr>
<tr>
<td>C</td>
<td>15</td>
</tr>
<tr>
<td>D</td>
<td>35</td>
</tr>
</tbody>
</table>
<p>再过5ms，此时A事件的定时时间就到了，需要被执行，在RTC闹钟链表中的表现是RTC Alarm中断触发，在嘀嗒定时链表中的表现是A事件的定时时间逐渐减少至0。当A事件被执行之后两种定时器链表中的存储都发生了变化，都是原先的链表的头指针指向原先的第二个节点，而原先的头节点被释放。</p>
<p>还是上述的例子，在定时器执行了7ms的时候，这时有个事件需要插入，为E 24ms，此时，两种链表对于此事件器的插入操作也会明显不同。</p>
<p>RTC闹钟插入之后</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>C</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>10</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
</tr>
<tr>
<td>D</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>而嘀嗒定时器在插入之后为</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>3</td>
</tr>
<tr>
<td>B</td>
<td>13</td>
</tr>
<tr>
<td>C</td>
<td>23</td>
</tr>
<tr>
<td>D</td>
<td>33</td>
</tr>
<tr>
<td>E</td>
<td>24</td>
</tr>
</tbody>
</table>
<p>以下是RTC闹钟的部分插入代码，其中可以看到他的定时器插入的逻辑<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">elapsedTime = TimerGetValue( );<span class="comment">//获取距离上一次设置闹钟的时间</span></div><div class="line">remainingTime = TimerListHead-&gt;Timestamp - elapsedTime;<span class="comment">//remainingTime表示剩余的头节点中的事件剩余的定时事件，因为此链表是按顺序存储的，所以头节点中的定时时间一定是最少的</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TimerInsertNewHeadTimer</span><span class="params">( TimerEvent_t *obj, <span class="keyword">uint32_t</span> remainingTime )</span></span></div><div class="line">&#123;</div><div class="line">    TimerEvent_t* cur = TimerListHead;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( cur != <span class="literal">NULL</span> )<span class="comment">//表头不为空，将新的定时器插入之前，将原先表头的定时器时间减去新定时器的定时时间，确保原先的定时器任务定时正常</span></div><div class="line">    &#123;</div><div class="line">        cur-&gt;Timestamp = remainingTime - obj-&gt;Timestamp;</div><div class="line">        cur-&gt;IsRunning = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    obj-&gt;Next = cur;</div><div class="line">    obj-&gt;IsRunning = <span class="literal">true</span>;</div><div class="line">    TimerListHead = obj;</div><div class="line">    TimerSetTimeout( TimerListHead );<span class="comment">//设置超时，等时间到的时候，会发生RTC报警</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外还有一点，此RTC中的1s并非物理时间的1s，在此具体的时间基准如下:<br>    此项目中，使用的RTC的时钟源为32.768Khz的LSE，通过AsynchPrediv和SynchPrediv分频得到2.048KHz的RTCtick，计算公式为32.768/(3+1)/(3+1) = 2.048;<br>相关的配置代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RtcInit</span><span class="params">( <span class="keyword">void</span> )</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	RtcHandle.Init.AsynchPrediv = <span class="number">3</span>;</div><div class="line">    RtcHandle.Init.SynchPrediv = <span class="number">3</span>;	</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line"> * RTC Time base in ms</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_DURATION                     0.48828125      <span class="comment">// 1 tick every 488us</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_PER_MS                       2.048           <span class="comment">// 1/2.048 = tick duration in ms</span></span></div></pre></td></tr></table></figure></p>
<p>由于原本每个tick相当于1s，而在这里，每个tick相当于0.48828125ms，小于1ms，所以在程序中能够实现ms级的定时任务。</p>
<p>RTC定时器的用法主要分为三步：</p>
<pre><code>1. 初始化，注册回调函数
    void TimerInit( TimerEvent_t *obj, void ( *callback )( void ) )//设置回调函数
2. 设置定时时间
    void TimerSetValue( TimerEvent_t *obj, uint32_t value )
3. 开启定时时间
    void TimerStart( TimerEvent_t *obj )
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN架构解析(二)--LoRaWAN MAC解析]]></title>
      <url>http://yoursite.com/2016/07/29/LoRaWAN_MAC%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><p>上行：终端的数据发送经过一个或多个网关中转到达网络服务器。<br>下行：由网络服务器发送给终端设备，每条消息对应的终端设备是唯一确定的，而且只通过一个网关中转。</p>
<h2 id="LoRaWAN-Classes"><a href="#LoRaWAN-Classes" class="headerlink" title="LoRaWAN Classes"></a>LoRaWAN Classes</h2><p>LoRaWAN Classes 一共分为3类：Class A,Class B,Class C</p>
<p>Class A:终端先发送，在发送后开启一段时间的接收窗口，终端只有在发送后才可以接收。也就是说上行没有限制，下行的数据只有在上行包发送上来的时候终端才可以接收到。(功耗最低)</p>
<p>Class B:终端和服务器协商好接收的窗口开启的时间以及何时开启，然后再约定的时间进行接收，可以一次接收多个包。（功耗次低）</p>
<p>Class C:终端在发送以外的其他时间都开启接收窗口。更耗能，但通讯延时最低。（功耗最高）</p>
<h2 id="PHY-层数据链路"><a href="#PHY-层数据链路" class="headerlink" title="PHY 层数据链路"></a>PHY 层数据链路</h2><p>上行链路消息：<br><img src="../../../../uploads/LoRa/uplink.png" alt=""></p>
<p>上行链路消息：<br><img src="../../../../uploads/LoRa/downlink.png" alt=""></p>
<p>其中上行最后还有CRC校验，而下行没有CRC校验。其中PHDR PHDR_CRC CRC都是射频芯片用于校准数据的完整新和一致性用的，并非用户生成的数据。</p>
<h2 id="MAC-层数据链路"><a href="#MAC-层数据链路" class="headerlink" title="MAC 层数据链路"></a>MAC 层数据链路</h2><p><img src="../../../../uploads/LoRa/PHY_data_format.png" alt=""></p>
<p>由上图可以看到，MAC数据是是作为PHYPayload存在的<br>其中MAC 层的包有三个部分组成：</p>
<ul>
<li>MHDR(MAC层帧头) </li>
<li>MACPayload(MAC层负载) </li>
<li>MIC(4字节的校验)</li>
</ul>
<p>而MACPayload又由三个部分组成:</p>
<ul>
<li>FHDR (MAC层负载头)</li>
<li>FPORT（MAC 层数据的通道号）</li>
<li>FRMPayload（MAC层负载，加密）</li>
</ul>
<p>而FHDR又由由四个部分组成:</p>
<ul>
<li>DevAddr(终端的ID 4字节)</li>
<li>FCtrl（帧的控制字 1个字节）</li>
<li>FCnt （帧的序号 2个字节）</li>
<li>FOpts（帧配置，字节数不定，大部分情况0个字节）</li>
</ul>
<p>所以，由协议可知，一个上行包或者下行包中的数据内容有哪些，抛开控制命令不说，主要有终端的ID、包的序号、用户的加密负载。</p>
<p>例如我抓到的一个数据包：</p>
<p>\x40 \x7f \xf8 \x8a \x29 \x80 \x2a \x00 \x02 \x07 \x42 \x87 \x3f \xc7 \xb4 \x22 \x04 \x00 \x84 \x8d \x1b \x06 \x2f \x5b \xbc \x57 \xdb \xf2 \x31 \xde \x49 \x61 \x00 \x86 \x99 \xec \x08 \x61 \xf0 \xb7 \xda \x54 \x0a \xfa \xd1 \x31 \xac \xd0 \x44 \x1b \x4d \xfa \x48 \x77 \x19 \xee \x61 \x14 \xbf \x23 \x52 \xd1 \xe9 \x93 \x79 \x6e \x16 \xd7 \x13 \x2e \x58 \x06 \x54 \xc3 \xd2 \x04 \xba \x52 \xa7 \xc8 \x7a \x0b \x8e </p>
<p>这是一个MAC 层的帧即完整的MACPayload部分</p>
<p>其中 </p>
<ul>
<li>MHDR:<br>  \x40</li>
<li>MACPayload-FHDR-DevAddr:<br>  \x7f \xf8 \x8a \x29 </li>
<li>MACPayload-FHDR-FCtrl:<br>  \x80 </li>
<li>MACPayload-FHDR-FCnt:<br>  \x2a \x00 </li>
<li>MACPayload-FPORT:<br>  \x02 </li>
<li>MACPayload-FRMPayload（加密）:<br>  \x07 \x42 \x87 \x3f \xc7 \xb4 \x22 \x04 \x00 \x84 \x8d \x1b \x06 \x2f \x5b \xbc \x57 \xdb \xf2 \x31 \xde \x49 \x61 \x00 \x86 \x99 \xec \x08 \x61 \xf0 \xb7 \xda \x54 \x0a \xfa \xd1 \x31 \xac \xd0 \x44 \x1b \x4d \xfa \x48 \x77 \x19 \xee \x61 \x14 \xbf \x23 \x52 \xd1 \xe9 \x93 \x79 \x6e \x16 \xd7 \x13 \x2e \x58 \x06 \x54 \xc3 \xd2 \x04 \xba \x52 \xa7 </li>
<li>MIC:<br>  \xc8 \x7a \x0b \x8e </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MPU9250调试]]></title>
      <url>http://yoursite.com/2016/07/26/MPU9250%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="MPU9250-芯片概述"><a href="#MPU9250-芯片概述" class="headerlink" title="MPU9250 芯片概述"></a>MPU9250 芯片概述</h2><p>MPU9250芯片是一个9轴姿态传感芯片，其中包含了3轴加速度传感器、3轴角速度传感器以及三轴磁力计。<br>其本质上是MPU6050芯片+AK8963。</p>
<p>可以获取传感芯片的加速度、角速度、以及磁力值。</p>
<p>角速度可以知芯片的转动速度，加速度可以知道芯片运动的距离、速度情况，而磁力计可以知道物芯片的运动方向。</p>
<p>另外MPU9250芯片内置DMP姿态融合器，可以在不涉及算法的情况下，直接读取出描述物体状态的四元数，从而得出物体的三维角度–航向角、翻滚角、俯仰角。</p>
<h2 id="驱动程序的设计"><a href="#驱动程序的设计" class="headerlink" title="驱动程序的设计"></a>驱动程序的设计</h2><p>由于MPU9250芯片使用的是I2C接口，所以在这里，我首先需要I2C的驱动。</p>
<p>在我的驱动中，I2C使用GPIO口模拟的，因为这样在以后移植时更加方便。</p>
<p>在完成IOI2C的驱动之后，就是对MPU9250的寄存器进行操作，来成功获取传感数据。</p>
<h2 id="MPU9250的寄存器操作"><a href="#MPU9250的寄存器操作" class="headerlink" title="MPU9250的寄存器操作"></a>MPU9250的寄存器操作</h2><p>操作MPU9250寄存器并且开启DMP模式，获取三维角度，其步骤如下：</p>
<ol>
<li>配置PWR_MGMT_1(一般为00，表示使用内部晶振20Mhz)</li>
<li>设置采样频率</li>
<li>设置量程（角速度、加速度量程）</li>
<li>外部中断打开，并且配置成相应的工作方式</li>
<li>开启DMP，以及FIFO</li>
</ol>
<p>其中DMP的开启需要密码，而且具体的操作方法及寄存器在数据手册上都无法找到，是本人在网站经过查找融合了多人的驱动调试出来的。</p>
<p>具体的程序在我的代码库中，欢迎大家能找出其中的不足，并提出来，当然有PR就更好了。</p>
<p>代码链接如下：<br><a href="https://github.com/AnswerInTheWind/Peripheral/tree/master/MPU9250-MPU6050" target="_blank" rel="external">MPU9250-MPU6050驱动</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN解析(一)--架构解析]]></title>
      <url>http://yoursite.com/2016/07/24/LoRaWan%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="LoRaWAN-分层"><a href="#LoRaWAN-分层" class="headerlink" title="LoRaWAN 分层"></a>LoRaWAN 分层</h2><p>LoRaWAN从底层到最后用户拿到数据的通讯过程通讯大致可分为三段：</p>
<ol>
<li>MOTE &lt;—&gt; GW (MAC层)</li>
<li>GW &lt;—&gt; NS</li>
<li>NS &lt;—&gt; Customer</li>
</ol>
<p>LoRa联盟 规定了 MAC层的通讯协议，只有在设备（GW、MOTE）共同遵守的MAC层协议的前提下，不同硬件厂商的设备才能互相接入。</p>
<p>而GW &lt;—&gt; NS以及NS &lt;—&gt; Customer这两层的协议虽然LoRa联盟有所规范，但不同厂商之间可能会存在不同。</p>
<h2 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h2><p>在这里我以LoRaWAN 方式实现农场的土壤湿度检测来做说明。<br>实现农场的土壤湿度的检测主要分为几个步骤：</p>
<ul>
<li>实现传感器采集土壤湿度（sensor层）</li>
<li>将采集到的土壤湿度通过MOTE发送给GW(LoRaMac 层)</li>
<li>GW将收到的数据发送给NS（GW&lt;—&gt;NS）</li>
<li>NS再将数据发送给用户(NS&lt;—&gt;Customer)</li>
<li>用户通过APP或者其他方式可以看到土壤的湿度状态。(Display)</li>
</ul>
<p>通过以上的几个步骤，就可以实现远程监控农场土壤湿度。</p>
<p>好了，第一讲非常的简单。只是讲解了LoRaWAN 作为IOT的一种方式，其中的数据流向。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cJSON_json包的C语言解析库]]></title>
      <url>http://yoursite.com/2016/07/21/CJSON_JSON%E5%8C%85%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="cJSON库描述"><a href="#cJSON库描述" class="headerlink" title="cJSON库描述"></a>cJSON库描述</h2><p>CJSON是一个用于解析JSON包的C语言库，库文件为cJSON.c和cJSON.h，<br>所有的实现都在这两个文件中。原作者的地址<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="external">cJSON</a>。</p>
<h2 id="JSON包的解析"><a href="#JSON包的解析" class="headerlink" title="JSON包的解析"></a>JSON包的解析</h2><p>例如有一个JSON的数据包如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"rxpk"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tmst"</span>: <span class="number">1868500100</span>,</div><div class="line">            <span class="string">"time"</span>: <span class="string">"2016-07-07T13:20:40.003906Z"</span>,</div><div class="line">            <span class="string">"chan"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"rfch"</span>: <span class="number">0</span>,</div><div class="line">            <span class="string">"freq"</span>: <span class="number">779.7</span>,</div><div class="line">            <span class="string">"stat"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"modu"</span>: <span class="string">"LORA"</span>,</div><div class="line">            <span class="string">"datr"</span>: <span class="string">"SF9BW125"</span>,</div><div class="line">            <span class="string">"codr"</span>: <span class="string">"4/5"</span>,</div><div class="line">            <span class="string">"lsnr"</span>: <span class="number">9.8</span>,</div><div class="line">            <span class="string">"rssi"</span>: <span class="number">-37</span>,</div><div class="line">            <span class="string">"size"</span>: <span class="number">83</span>,</div><div class="line">            <span class="string">"data"</span>: <span class="string">"QH/4iimAKgACB0KHP8e0IgQAhI0bBi9bvFfb8jHeSWEAhpnsCGHwt9pUCvrRMazQRBtN+kh3Ge5hFL8jUtHpk3luFtcTLlgGVMPSBLpSp8h6C44="</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要获取其中的data字段，需要进行的过程如下：</p>
<ol>
<li><p>首先声明变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cJSON *json;</div><div class="line">cJSON *rxpk;		</div><div class="line">cJSON *arr0;</div><div class="line">cJSON *data;</div></pre></td></tr></table></figure>
</li>
<li><p>将上述的字符串进行解析,并保存在json中;</p>
</li>
<li>获取json其中的rxpk字段的内容，并保存在rxpk中;</li>
<li>获取rxpk中的arr部分，拿出一种的第一个数组，并保存在arr0;</li>
<li>获取arr0的data部分，并保存在data;</li>
<li>使用data-&gt;valuestring即可获取其中的data字段的内容<br>具体的代码实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint16_t</span> rxpk_data_get(<span class="keyword">char</span>* text,<span class="keyword">char</span>* dest_str)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint16_t</span> len = <span class="number">0</span>;</div><div class="line">    cJSON *json;</div><div class="line">    cJSON *data;</div><div class="line">    cJSON *arr0;</div><div class="line">    cJSON *rxpk;</div><div class="line"></div><div class="line">    json= cJSON_Parse(text);</div><div class="line">    <span class="keyword">if</span>(!json)<span class="comment">//对JSON包进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    rxpk = cJSON_GetObjectItem(json,<span class="string">"rxpk"</span>);</div><div class="line">    <span class="keyword">if</span>(!rxpk)<span class="comment">//对rxpk进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    arr0 = cJSON_GetArrayItem(rxpk,<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(!arr0)<span class="comment">//对arr0进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    data =cJSON_GetObjectItem(arr0,<span class="string">"data"</span>);</div><div class="line">    <span class="keyword">if</span>(!data)<span class="comment">//对data进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    len = <span class="built_in">strlen</span>(data-&gt;valuestring);</div><div class="line">    <span class="built_in">memcpy</span>(dest_str,data-&gt;valuestring,len);</div><div class="line">    dest_str[len] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在json包中遇到数组时<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Returns the number of items in an array (or object). */</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span>	  <span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数可以获取数组的长度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[74HC165的级联以及MCU硬件SPI的通讯]]></title>
      <url>http://yoursite.com/2016/07/21/74HC165/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>74HC165作为常用的IO口扩展芯片，常用于并行IO口状态转串行数据。一块74HC165芯片可以连接8个IO口，将8个IO口状态转换成8位串行的数据传输给MCU。也就是说可以通过两个IO口获取到8个IO口的状态。<br>在电路设计中，也经常将74HC165芯片级联使用。通过芯片的级联，可以达到2个IO口读取16个IO口状态（2片级联）的效果，甚至更多。</p>
<p>由于74HC165的操作时序刚SPI的时序恰好相同，所以可以通过MCU的硬件SPI接口来操作74HC165芯片，这种通过MCU硬件接口来操作芯片的优点如下：</p>
<ul>
<li>硬件的SPI时钟速度高，STM32芯片舌诊可以达到20MHZ，这样获取IO口状态的速度快，实时性更强</li>
<li>扫描周期更短，可以使用在一些判断IO口状态的应用中，如扫描是否有物体高速穿过</li>
</ul>
<h2 id="软件的实现思路"><a href="#软件的实现思路" class="headerlink" title="软件的实现思路"></a>软件的实现思路</h2><p>由于使用的是MCU的硬件SPI接口，所以程序和MCU的型号会有较大关系，在这里，我以STM32F103RCT6为例。</p>
<p>步骤如下:</p>
<ol>
<li>将MCU的SPI复用IO口初始化</li>
<li><p>配置SPI寄存器,示例代码如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SPI_I2S_DeInit(SPI1);</div><div class="line">SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;<span class="comment">// Receive-only mode</span></div><div class="line">SPI_InitStructure.SPI_Mode=SPI_Mode_Master;<span class="comment">// </span></div><div class="line">SPI_InitStructure.SPI_DataSize=SPI_DataSize_16b;<span class="comment">// Data word = 16 bit wide</span></div><div class="line">SPI_InitStructure.SPI_CPOL=SPI_CPOL_High;<span class="comment">// Clock default level = L</span></div><div class="line">SPI_InitStructure.SPI_CPHA=SPI_CPHA_1Edge;<span class="comment">// Latch on the first edge (rising from L)</span></div><div class="line">SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;<span class="comment">// Software controls select SS signal, SS pin is GPIO</span></div><div class="line">SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_4; <span class="comment">// SPI_BaudRatePrescaler_4</span></div><div class="line">SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_LSB;<span class="comment">// MSB first</span></div><div class="line">SPI_InitStructure.SPI_CRCPolynomial=<span class="number">7</span>;<span class="comment">// No CRC required</span></div><div class="line">SPI_Init(SPI1, &amp;SPI_InitStructure);</div></pre></td></tr></table></figure>
<p> 其中需要注意的是分频的值和数据位长度，由于这边是2片级联，所以使用的是16b</p>
</li>
<li><p>SPI读取，代码如下： </p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GPIOC-&gt;BSRR = GPIO_Pin_5;<span class="comment">//片选选中</span></div><div class="line"></div><div class="line"><span class="keyword">while</span>((SPI1-&gt;SR &amp; SPI_I2S_FLAG_TXE) == <span class="number">0</span>);<span class="comment">//判断数据发送完成</span></div><div class="line">SPI1-&gt;DR = <span class="number">0xFFFF</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span>((SPI1-&gt;SR &amp; SPI_I2S_FLAG_RXNE) == <span class="number">0</span>);<span class="comment">//判断数据接受完成</span></div><div class="line">temp1 = SPI1-&gt;DR;</div><div class="line"></div><div class="line">GPIOC-&gt;BRR = GPIO_Pin_5;<span class="comment">//片选取消选中</span></div></pre></td></tr></table></figure>
<p> 思路就是利用硬件的SPI时序以及SPI每写一位就会返回一位的特性，向74HC165芯片写入16bit的数据,便会在SPI寄存器中获取到两片级联的74HC165的状态。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[base64的C语言实现]]></title>
      <url>http://yoursite.com/2016/07/21/base64_C/</url>
      <content type="html"><![CDATA[<p>首先谢谢这位大神的<a href="https://github.com/zhicheng" target="_blank" rel="external">github</a>,再谢谢这位大神分享的base64的C语言实现代码，库的地址在这里<a href="https://github.com/zhicheng/base64" target="_blank" rel="external">base64</a>。</p>
<p>其中提供的接口非常的简单明了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_ENCODE_OUT_SIZE(s)	(((s) + 2) / 3 * 4)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_DECODE_OUT_SIZE(s)	(((s)) / 4 * 3)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen,<span class="keyword">char</span> *out)</span></span>;</div></pre></td></tr></table></figure></p>
<p>但是其中有一个问题，base64_decode();函数在返回时并没有返回解码后的字节数，在使用上会存在不方便的情况。</p>
<p>故，我把这个函数稍加修改之后,在解码之后返回解码数组的长度，在使用上就方便很多了，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; inlen; i++) &#123;</div><div class="line">		<span class="keyword">int</span> c;</div><div class="line">		<span class="keyword">int</span> s = i % <span class="number">4</span>; 			<span class="comment">/* from 8/gcd(6, 8) */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] == <span class="string">'='</span>)</div><div class="line">			<span class="keyword">return</span> j;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] &lt; BASE64DE_FIRST || in[i] &gt; BASE64DE_LAST ||</div><div class="line">		    (c = base64de[in[i] - BASE64DE_FIRST]) == <span class="number">-1</span>)</div><div class="line">			<span class="keyword">return</span> j;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (s) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">			out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFF</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x3</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">3</span>) || in[inlen - <span class="number">2</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">4</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">2</span>) || in[inlen - <span class="number">1</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] =  ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">6</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			out[j++] += (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> input[] = <span class="string">"pleasure."</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> decode[<span class="number">13</span>];</div><div class="line">	<span class="keyword">char</span> output[<span class="number">13</span>];</div><div class="line">	<span class="keyword">uint16_t</span> len_decode = <span class="number">0</span>;</div><div class="line">	bzero(output, <span class="keyword">sizeof</span>(output));</div><div class="line">	base64_encode(input, <span class="keyword">sizeof</span>(input) - <span class="number">1</span>, output);</div><div class="line">	len_decode = base64_decode(output, <span class="keyword">sizeof</span>(output) - <span class="number">1</span>, decode);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以帧为存储单位的循环stack]]></title>
      <url>http://yoursite.com/2016/07/11/%E6%9E%84%E5%BB%BA%E4%BB%A5%E5%B8%A7%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84stack/</url>
      <content type="html"><![CDATA[<p>此stack主要是作为存储空间使用，主要的借口就是push和pop。</p>
<p>stack frame的src以及例程位于<a href="https://github.com/AnswerInTheWind/Data_Structure/tree/master/stack_FrameTest" target="_blank" rel="external">stack_FrameTest</a>这个库当中，其中有readme文件，可以快速上手。</p>
<h2 id="stack构造及代码实现"><a href="#stack构造及代码实现" class="headerlink" title="stack构造及代码实现"></a>stack构造及代码实现</h2><p>其中我对stack以及frame的构造的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Frame</div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint8_t</span> frame_len;<span class="comment">//帧的字节数</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_data[MAX_TRANSMISSION_UINT];<span class="comment">//一帧数据最大为MAX_TRANSMISSION_UINT字节</span></div><div class="line">&#125;Frame;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STACK</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int8_t</span> frame_lastNum;<span class="comment">//最新的帧的序号</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_count;<span class="comment">//stack中未取出的帧的个数</span></div><div class="line">	Frame frame_info[MAX_STACK_FRAME_NUM];<span class="comment">//stack中最多允许存储MAX_STACK_FRAME_NUM个帧</span></div><div class="line">&#125;STACK;</div></pre></td></tr></table></figure></p>
<p>首先构造了一个stack，stack包含两个内容:</p>
<ol>
<li>stack的统计信息：stack中帧的个数(frame_count)，最新的帧的ID(frame_lastNum)；</li>
<li>数据存储区–一个数组，数据格式为Frame，容量为MAX_STACK_FRAME_NUM(frame_info[MAX_STACK_FRAME_NUM])；</li>
</ol>
<p>然后，帧的构造也包含了两个部分：</p>
<ol>
<li>此帧数据的字节数(frame_len)；</li>
<li>数据存储空间–数组,数据格式为uint8_t,容量为MAX_TRANSMISSION_UINT(frame_data[MAX_TRANSMISSION_UINT])；</li>
</ol>
<p>另外，此stack为一个循环栈，当stack存满之后仍有数据存入，并不会发生越界，而是会从头开始覆盖，此种操作，有利也有弊。</p>
<h2 id="拼包机制"><a href="#拼包机制" class="headerlink" title="拼包机制"></a>拼包机制</h2><p>在最后，此例程中还写了一个拼包的机制，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将stack中的数据进行拼包,在不造成断包的情况下最大限度地拼包</span></div><div class="line"><span class="keyword">uint8_t</span> SpliceFrame(<span class="keyword">uint8_t</span>* dest)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">		<span class="comment">//确保当前数据加下一帧数据不会超过最大单帧负载量(MTU)</span></div><div class="line">        <span class="keyword">if</span>((Splice_len +Stack_GetFrameLastNum()) &lt;= MAX_TRANSMISSION_UINT)</div><div class="line">        &#123;</div><div class="line">            Splice_len +=Stack_PopData(dest+Splice_len);<span class="comment">//</span></div><div class="line">            <span class="keyword">if</span>(Stack_GetFrameCount() == <span class="number">0</span>)<span class="comment">//当前融合帧的数量小于stack中已存帧的数量</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Splice_len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>思路就是假如当MTU=70，而如果收到的数据为10bytes，10bytes这样的短数据，我们就可以把这样的短数据由多个包拼接成一个包，一次性发送出去，提高通道的利用效率，因为一次发送70个字节所需的时间大约为5s，而一次发送10个字节的时间也基本等于5s，但是拼包的时候如果造成断包，在接收端处理会非常的麻烦，所以拼包机制制定成这样–在不造成断包以及不超过MTU的情况下最大限度地拼包。</p>
<p>有任何问题欢迎联系我。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32L051 PVD的调试]]></title>
      <url>http://yoursite.com/2016/07/11/STM32_PVD/</url>
      <content type="html"><![CDATA[<p>我的PVD的驱动以及例程位于<a href="http://https://github.com/AnswerInTheWind/STM32L0xx_Drivers" title="STM32L0xx_Drivers" target="_blank" rel="external">STM32L0xx_Drivers</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>PVD 是一种检测MCU供电情况的技术。当供电电压高于或者低于一定阈值的时候，可以在寄存器上体现出来，或者直接产生硬件中断。<br>在实际使用MCU时，特别是电池供电的方案中，往往会遇到供电不够导致MCU或者外设工作不正常的情况。PVD在这个时候就可以派上用场了。<br>PVD的使用按照数据手册上的说明，就是首先设置PVD阈值（PVD thresholds），当MCU的VDD引脚的电压高于阈值时，则PVD output=1，当VDD电压低于阈值时，PVD output=0，如下图所示：</p>
<p><img src="../../../../uploads/PVD_images/PVD_1.jpg" alt=""></p>
<p>其中PVD output的结果可以再在存器中查看到 </p>
<p><img src="../../../../uploads/PVD_images/PVD_4.jpg" alt=""><br><img src="../../../../uploads/PVD_images/PVD_3.jpg" alt=""></p>
<p>关于PVD的阈值的设定共有两种方式：</p>
<ul>
<li>固定阈值(1.9V 2.1V 2.3V 2.5V 2.7V 2.9V 3.1V)</li>
<li>与引脚比较（PB7）</li>
</ul>
<p>在实际使用的过程中,PVD可以用查询挥着中断的方式来工作。</p>
<p>在测试的例程中，我配置PVD工作方式为中断上升下降沿触发，当VDD高于预设PVD阈值或者低于阈值而产生边沿触发时，都会形成一次PVD中断，然后读取PWR_CSR的PVDO标志位检查是低电压提醒还是高电压提醒，以此来达到监控MCU供电情况的目的。</p>
<p>注意：当使用PVD功能检测低电压时，VDD电压刚刚小于阈值时并不会直接产生PVD中断，只有当VDD电压小于（阈值-50MV）时，才会产生中断。</p>
<p>如果有什么疑问或者错误欢迎大家指正，email:454626653@qq.com</p>
]]></content>
    </entry>
    
  
  
</search>
