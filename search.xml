<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LoRaWAN架构解析(二)--LoRaWAN MAC解析]]></title>
      <url>http://yoursite.com/2016/07/29/LoRaWAN_MAC%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><p>上行：终端的数据发送经过一个或多个网关中转到达网络服务器。<br>下行：由网络服务器发送给终端设备，每条消息对应的终端设备是唯一确定的，而且只通过一个网关中转。</p>
<h2 id="LoRaWAN-Classes"><a href="#LoRaWAN-Classes" class="headerlink" title="LoRaWAN Classes"></a>LoRaWAN Classes</h2><p>LoRaWAN Classes 一共分为3类：Class A,Class B,Class C</p>
<p>Class A:终端先发送，在发送后开启一段时间的接收窗口，终端只有在发送后才可以接收。也就是说上行没有限制，下行的数据只有在上行包发送上来的时候终端才可以接收到。(功耗最低)</p>
<p>Class B:终端和服务器协商好接收的窗口开启的时间以及何时开启，然后再约定的时间进行接收，可以一次接收多个包。（功耗次低）</p>
<p>Class C:终端在发送以外的其他时间都开启接收窗口。更耗能，但通讯延时最低。（功耗最高）</p>
<h2 id="PHY-层数据链路"><a href="#PHY-层数据链路" class="headerlink" title="PHY 层数据链路"></a>PHY 层数据链路</h2><p>上行链路消息：<br><img src="../../../../uploads/LoRa/uplink.png" alt=""></p>
<p>上行链路消息：<br><img src="../../../../uploads/LoRa/downlink.png" alt=""></p>
<p>其中上行最后还有CRC校验，而下行没有CRC校验。其中PHDR PHDR_CRC CRC都是射频芯片用于校准数据的完整新和一致性用的，并非用户生成的数据。</p>
<h2 id="MAC-层数据链路"><a href="#MAC-层数据链路" class="headerlink" title="MAC 层数据链路"></a>MAC 层数据链路</h2><p><img src="../../../../uploads/LoRa/PHY_data_format.png" alt=""></p>
<p>由上图可以看到，MAC数据是是作为PHYPayload存在的<br>其中MAC 层的包有三个部分组成：</p>
<ul>
<li>MHDR(MAC层帧头) </li>
<li>MACPayload(MAC层负载) </li>
<li>MIC(4字节的校验)</li>
</ul>
<p>而MACPayload又由三个部分组成:</p>
<ul>
<li>FHDR (MAC层负载头)</li>
<li>FPORT（MAC 层数据的通道号）</li>
<li>FRMPayload（MAC层负载，加密）</li>
</ul>
<p>而FHDR又由由四个部分组成:</p>
<ul>
<li>DevAddr(终端的ID 4字节)</li>
<li>FCtrl（帧的控制字 1个字节）</li>
<li>FCnt （帧的序号 2个字节）</li>
<li>FOpts（帧配置，字节数不定，大部分情况0个字节）</li>
</ul>
<p>所以，由协议可知，一个上行包或者下行包中的数据内容有哪些，抛开控制命令不说，主要有终端的ID、包的序号、用户的加密负载。</p>
<p>例如我抓到的一个数据包：</p>
<p>\x40 \x7f \xf8 \x8a \x29 \x80 \x2a \x00 \x02 \x07 \x42 \x87 \x3f \xc7 \xb4 \x22 \x04 \x00 \x84 \x8d \x1b \x06 \x2f \x5b \xbc \x57 \xdb \xf2 \x31 \xde \x49 \x61 \x00 \x86 \x99 \xec \x08 \x61 \xf0 \xb7 \xda \x54 \x0a \xfa \xd1 \x31 \xac \xd0 \x44 \x1b \x4d \xfa \x48 \x77 \x19 \xee \x61 \x14 \xbf \x23 \x52 \xd1 \xe9 \x93 \x79 \x6e \x16 \xd7 \x13 \x2e \x58 \x06 \x54 \xc3 \xd2 \x04 \xba \x52 \xa7 \xc8 \x7a \x0b \x8e </p>
<p>这是一个MAC 层的帧即完整的MACPayload部分</p>
<p>其中 </p>
<ul>
<li>MHDR:<br>  \x40</li>
<li>MACPayload-FHDR-DevAddr:<br>  \x7f \xf8 \x8a \x29 </li>
<li>MACPayload-FHDR-FCtrl:<br>  \x80 </li>
<li>MACPayload-FHDR-FCnt:<br>  \x2a \x00 </li>
<li>MACPayload-FPORT:<br>  \x02 </li>
<li>MACPayload-FRMPayload（加密）:<br>  \x07 \x42 \x87 \x3f \xc7 \xb4 \x22 \x04 \x00 \x84 \x8d \x1b \x06 \x2f \x5b \xbc \x57 \xdb \xf2 \x31 \xde \x49 \x61 \x00 \x86 \x99 \xec \x08 \x61 \xf0 \xb7 \xda \x54 \x0a \xfa \xd1 \x31 \xac \xd0 \x44 \x1b \x4d \xfa \x48 \x77 \x19 \xee \x61 \x14 \xbf \x23 \x52 \xd1 \xe9 \x93 \x79 \x6e \x16 \xd7 \x13 \x2e \x58 \x06 \x54 \xc3 \xd2 \x04 \xba \x52 \xa7 </li>
<li>MIC:<br>  \xc8 \x7a \x0b \x8e </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MPU9250调试]]></title>
      <url>http://yoursite.com/2016/07/26/MPU9250%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="MPU9250-芯片概述"><a href="#MPU9250-芯片概述" class="headerlink" title="MPU9250 芯片概述"></a>MPU9250 芯片概述</h2><p>MPU9250芯片是一个9轴姿态传感芯片，其中包含了3轴加速度传感器、3轴角速度传感器以及三轴磁力计。<br>其本质上是MPU6050芯片+AK8963。</p>
<p>可以获取传感芯片的加速度、角速度、以及磁力值。</p>
<p>角速度可以知芯片的转动速度，加速度可以知道芯片运动的距离、速度情况，而磁力计可以知道物芯片的运动方向。</p>
<p>另外MPU9250芯片内置DMP姿态融合器，可以在不涉及算法的情况下，直接读取出描述物体状态的四元数，从而得出物体的三维角度–航向角、翻滚角、俯仰角。</p>
<h2 id="驱动程序的设计"><a href="#驱动程序的设计" class="headerlink" title="驱动程序的设计"></a>驱动程序的设计</h2><p>由于MPU9250芯片使用的是I2C接口，所以在这里，我首先需要I2C的驱动。</p>
<p>在我的驱动中，I2C使用GPIO口模拟的，因为这样在以后移植时更加方便。</p>
<p>在完成IOI2C的驱动之后，就是对MPU9250的寄存器进行操作，来成功获取传感数据。</p>
<h2 id="MPU9250的寄存器操作"><a href="#MPU9250的寄存器操作" class="headerlink" title="MPU9250的寄存器操作"></a>MPU9250的寄存器操作</h2><p>操作MPU9250寄存器并且开启DMP模式，获取三维角度，其步骤如下：</p>
<ol>
<li>配置PWR_MGMT_1(一般为00，表示使用内部晶振20Mhz)</li>
<li>设置采样频率</li>
<li>设置量程（角速度、加速度量程）</li>
<li>外部中断打开，并且配置成相应的工作方式</li>
<li>开启DMP，以及FIFO</li>
</ol>
<p>其中DMP的开启需要密码，而且具体的操作方法及寄存器在数据手册上都无法找到，是本人在网站经过查找融合了多人的驱动调试出来的。</p>
<p>具体的程序在我的代码库中，欢迎大家能找出其中的不足，并提出来，当然有PR就更好了。</p>
<p>代码链接如下：<br><a href="https://github.com/AnswerInTheWind/Peripheral/tree/master/MPU9250-MPU6050" target="_blank" rel="external">MPU9250(MPU6050)驱动</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN解析(一)--架构解析]]></title>
      <url>http://yoursite.com/2016/07/24/LoRaWan%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="LoRaWAN-分层"><a href="#LoRaWAN-分层" class="headerlink" title="LoRaWAN 分层"></a>LoRaWAN 分层</h2><p>LoRaWAN从底层到最后用户拿到数据的通讯过程通讯大致可分为三段：</p>
<ol>
<li>MOTE &lt;—&gt; GW (MAC层)</li>
<li>GW &lt;—&gt; NS</li>
<li>NS &lt;—&gt; Customer</li>
</ol>
<p>LoRa联盟 规定了 MAC层的通讯协议，只有在设备（GW、MOTE）共同遵守的MAC层协议的前提下，不同硬件厂商的设备才能互相接入。</p>
<p>而GW &lt;—&gt; NS以及NS &lt;—&gt; Customer这两层的协议虽然LoRa联盟有所规范，但不同厂商之间可能会存在不同。</p>
<h2 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h2><p>在这里我以LoRaWAN 方式实现农场的土壤湿度检测来做说明。<br>实现农场的土壤湿度的检测主要分为几个步骤：</p>
<ul>
<li>实现传感器采集土壤湿度（sensor层）</li>
<li>将采集到的土壤湿度通过MOTE发送给GW(LoRaMac 层)</li>
<li>GW将收到的数据发送给NS（GW&lt;—&gt;NS）</li>
<li>NS再将数据发送给用户(NS&lt;—&gt;Customer)</li>
<li>用户通过APP或者其他方式可以看到土壤的湿度状态。(Display)</li>
</ul>
<p>通过以上的几个步骤，就可以实现远程监控农场土壤湿度。</p>
<p>好了，第一讲非常的简单。只是讲解了LoRaWAN 作为IOT的一种方式，其中的数据流向。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cJSON_json包的C语言解析库]]></title>
      <url>http://yoursite.com/2016/07/21/CJSON_JSON%E5%8C%85%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="cJSON库描述"><a href="#cJSON库描述" class="headerlink" title="cJSON库描述"></a>cJSON库描述</h2><p>CJSON是一个用于解析JSON包的C语言库，库文件为cJSON.c和cJSON.h，<br>所有的实现都在这两个文件中。原作者的地址<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="external">cJSON</a>。</p>
<h2 id="JSON包的解析"><a href="#JSON包的解析" class="headerlink" title="JSON包的解析"></a>JSON包的解析</h2><p>例如有一个JSON的数据包如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"rxpk"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tmst"</span>: <span class="number">1868500100</span>,</div><div class="line">            <span class="string">"time"</span>: <span class="string">"2016-07-07T13:20:40.003906Z"</span>,</div><div class="line">            <span class="string">"chan"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"rfch"</span>: <span class="number">0</span>,</div><div class="line">            <span class="string">"freq"</span>: <span class="number">779.7</span>,</div><div class="line">            <span class="string">"stat"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"modu"</span>: <span class="string">"LORA"</span>,</div><div class="line">            <span class="string">"datr"</span>: <span class="string">"SF9BW125"</span>,</div><div class="line">            <span class="string">"codr"</span>: <span class="string">"4/5"</span>,</div><div class="line">            <span class="string">"lsnr"</span>: <span class="number">9.8</span>,</div><div class="line">            <span class="string">"rssi"</span>: <span class="number">-37</span>,</div><div class="line">            <span class="string">"size"</span>: <span class="number">83</span>,</div><div class="line">            <span class="string">"data"</span>: <span class="string">"QH/4iimAKgACB0KHP8e0IgQAhI0bBi9bvFfb8jHeSWEAhpnsCGHwt9pUCvrRMazQRBtN+kh3Ge5hFL8jUtHpk3luFtcTLlgGVMPSBLpSp8h6C44="</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要获取其中的data字段，需要进行的过程如下：</p>
<ol>
<li><p>首先声明变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cJSON *json;</div><div class="line">cJSON *rxpk;		</div><div class="line">cJSON *arr0;</div><div class="line">cJSON *data;</div></pre></td></tr></table></figure>
</li>
<li><p>将上述的字符串进行解析,并保存在json中;</p>
</li>
<li>获取json其中的rxpk字段的内容，并保存在rxpk中;</li>
<li>获取rxpk中的arr部分，拿出一种的第一个数组，并保存在arr0;</li>
<li>获取arr0的data部分，并保存在data;</li>
<li>使用data-&gt;valuestring即可获取其中的data字段的内容<br>具体的代码实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint16_t</span> rxpk_data_get(<span class="keyword">char</span>* text,<span class="keyword">char</span>* dest_str)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint16_t</span> len = <span class="number">0</span>;</div><div class="line">    cJSON *json;</div><div class="line">    cJSON *data;</div><div class="line">    cJSON *arr0;</div><div class="line">    cJSON *rxpk;</div><div class="line"></div><div class="line">    json= cJSON_Parse(text);</div><div class="line">    <span class="keyword">if</span>(!json)<span class="comment">//对JSON包进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    rxpk = cJSON_GetObjectItem(json,<span class="string">"rxpk"</span>);</div><div class="line">    <span class="keyword">if</span>(!rxpk)<span class="comment">//对rxpk进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    arr0 = cJSON_GetArrayItem(rxpk,<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(!arr0)<span class="comment">//对arr0进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    data =cJSON_GetObjectItem(arr0,<span class="string">"data"</span>);</div><div class="line">    <span class="keyword">if</span>(!data)<span class="comment">//对data进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    len = <span class="built_in">strlen</span>(data-&gt;valuestring);</div><div class="line">    <span class="built_in">memcpy</span>(dest_str,data-&gt;valuestring,len);</div><div class="line">    dest_str[len] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在json包中遇到数组时<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Returns the number of items in an array (or object). */</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span>	  <span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数可以获取数组的长度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[74HC165的级联以及MCU硬件SPI的通讯]]></title>
      <url>http://yoursite.com/2016/07/21/74HC165/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>74HC165作为常用的IO口扩展芯片，常用于并行IO口状态转串行数据。一块74HC165芯片可以连接8个IO口，将8个IO口状态转换成8位串行的数据传输给MCU。也就是说可以通过两个IO口获取到8个IO口的状态。<br>在电路设计中，也经常将74HC165芯片级联使用。通过芯片的级联，可以达到2个IO口读取16个IO口状态（2片级联）的效果，甚至更多。</p>
<p>由于74HC165的操作时序刚SPI的时序恰好相同，所以可以通过MCU的硬件SPI接口来操作74HC165芯片，这种通过MCU硬件接口来操作芯片的优点如下：</p>
<ul>
<li>硬件的SPI时钟速度高，STM32芯片舌诊可以达到20MHZ，这样获取IO口状态的速度快，实时性更强</li>
<li>扫描周期更短，可以使用在一些判断IO口状态的应用中，如扫描是否有物体高速穿过</li>
</ul>
<h2 id="软件的实现思路"><a href="#软件的实现思路" class="headerlink" title="软件的实现思路"></a>软件的实现思路</h2><p>由于使用的是MCU的硬件SPI接口，所以程序和MCU的型号会有较大关系，在这里，我以STM32F103RCT6为例。</p>
<p>步骤如下:</p>
<ol>
<li>将MCU的SPI复用IO口初始化</li>
<li><p>配置SPI寄存器,示例代码如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SPI_I2S_DeInit(SPI1);</div><div class="line">SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;<span class="comment">// Receive-only mode</span></div><div class="line">SPI_InitStructure.SPI_Mode=SPI_Mode_Master;<span class="comment">// </span></div><div class="line">SPI_InitStructure.SPI_DataSize=SPI_DataSize_16b;<span class="comment">// Data word = 16 bit wide</span></div><div class="line">SPI_InitStructure.SPI_CPOL=SPI_CPOL_High;<span class="comment">// Clock default level = L</span></div><div class="line">SPI_InitStructure.SPI_CPHA=SPI_CPHA_1Edge;<span class="comment">// Latch on the first edge (rising from L)</span></div><div class="line">SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;<span class="comment">// Software controls select SS signal, SS pin is GPIO</span></div><div class="line">SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_4; <span class="comment">// SPI_BaudRatePrescaler_4</span></div><div class="line">SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_LSB;<span class="comment">// MSB first</span></div><div class="line">SPI_InitStructure.SPI_CRCPolynomial=<span class="number">7</span>;<span class="comment">// No CRC required</span></div><div class="line">SPI_Init(SPI1, &amp;SPI_InitStructure);</div></pre></td></tr></table></figure>
<p> 其中需要注意的是分频的值和数据位长度，由于这边是2片级联，所以使用的是16b</p>
</li>
<li><p>SPI读取，代码如下： </p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GPIOC-&gt;BSRR = GPIO_Pin_5;<span class="comment">//片选选中</span></div><div class="line"></div><div class="line"><span class="keyword">while</span>((SPI1-&gt;SR &amp; SPI_I2S_FLAG_TXE) == <span class="number">0</span>);<span class="comment">//判断数据发送完成</span></div><div class="line">SPI1-&gt;DR = <span class="number">0xFFFF</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span>((SPI1-&gt;SR &amp; SPI_I2S_FLAG_RXNE) == <span class="number">0</span>);<span class="comment">//判断数据接受完成</span></div><div class="line">temp1 = SPI1-&gt;DR;</div><div class="line"></div><div class="line">GPIOC-&gt;BRR = GPIO_Pin_5;<span class="comment">//片选取消选中</span></div></pre></td></tr></table></figure>
<p> 思路就是利用硬件的SPI时序以及SPI每写一位就会返回一位的特性，向74HC165芯片写入16bit的数据,便会在SPI寄存器中获取到两片级联的74HC165的状态。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[base64的C语言实现]]></title>
      <url>http://yoursite.com/2016/07/21/base64_C/</url>
      <content type="html"><![CDATA[<p>首先谢谢这位大神的<a href="https://github.com/zhicheng" target="_blank" rel="external">github</a>,再谢谢这位大神分享的base64的C语言实现代码，库的地址在这里<a href="https://github.com/zhicheng/base64" target="_blank" rel="external">base64</a>。</p>
<p>其中提供的接口非常的简单明了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_ENCODE_OUT_SIZE(s)	(((s) + 2) / 3 * 4)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_DECODE_OUT_SIZE(s)	(((s)) / 4 * 3)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen,<span class="keyword">char</span> *out)</span></span>;</div></pre></td></tr></table></figure></p>
<p>但是其中有一个问题，base64_decode();函数在返回时并没有返回解码后的字节数，在使用上会存在不方便的情况。</p>
<p>故，我把这个函数稍加修改之后,在解码之后返回解码数组的长度，在使用上就方便很多了，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; inlen; i++) &#123;</div><div class="line">		<span class="keyword">int</span> c;</div><div class="line">		<span class="keyword">int</span> s = i % <span class="number">4</span>; 			<span class="comment">/* from 8/gcd(6, 8) */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] == <span class="string">'='</span>)</div><div class="line">			<span class="keyword">return</span> j;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] &lt; BASE64DE_FIRST || in[i] &gt; BASE64DE_LAST ||</div><div class="line">		    (c = base64de[in[i] - BASE64DE_FIRST]) == <span class="number">-1</span>)</div><div class="line">			<span class="keyword">return</span> j;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (s) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">			out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFF</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x3</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">3</span>) || in[inlen - <span class="number">2</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">4</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">2</span>) || in[inlen - <span class="number">1</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] =  ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">6</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			out[j++] += (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> input[] = <span class="string">"pleasure."</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> decode[<span class="number">13</span>];</div><div class="line">	<span class="keyword">char</span> output[<span class="number">13</span>];</div><div class="line">	<span class="keyword">uint16_t</span> len_decode = <span class="number">0</span>;</div><div class="line">	bzero(output, <span class="keyword">sizeof</span>(output));</div><div class="line">	base64_encode(input, <span class="keyword">sizeof</span>(input) - <span class="number">1</span>, output);</div><div class="line">	len_decode = base64_decode(output, <span class="keyword">sizeof</span>(output) - <span class="number">1</span>, decode);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32L051 PVD的调试]]></title>
      <url>http://yoursite.com/2016/07/11/STM32_PVD/</url>
      <content type="html"><![CDATA[<p>我的PVD的驱动以及例程位于<a href="http://https://github.com/AnswerInTheWind/STM32L0xx_Drivers" title="STM32L0xx_Drivers" target="_blank" rel="external">STM32L0xx_Drivers</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>PVD 是一种检测MCU供电情况的技术。当供电电压高于或者低于一定阈值的时候，可以在寄存器上体现出来，或者直接产生硬件中断。<br>在实际使用MCU时，特别是电池供电的方案中，往往会遇到供电不够导致MCU或者外设工作不正常的情况。PVD在这个时候就可以派上用场了。<br>PVD的使用按照数据手册上的说明，就是首先设置PVD阈值（PVD thresholds），当MCU的VDD引脚的电压高于阈值时，则PVD output=1，当VDD电压低于阈值时，PVD output=0，如下图所示：</p>
<p><img src="../../../../uploads/PVD_images/PVD_1.jpg" alt=""></p>
<p>其中PVD output的结果可以再在存器中查看到 </p>
<p><img src="../../../../uploads/PVD_images/PVD_4.jpg" alt=""><br><img src="../../../../uploads/PVD_images/PVD_3.jpg" alt=""></p>
<p>关于PVD的阈值的设定共有两种方式：</p>
<ul>
<li>固定阈值(1.9V 2.1V 2.3V 2.5V 2.7V 2.9V 3.1V)</li>
<li>与引脚比较（PB7）</li>
</ul>
<p>在实际使用的过程中,PVD可以用查询挥着中断的方式来工作。</p>
<p>在测试的例程中，我配置PVD工作方式为中断上升下降沿触发，当VDD高于预设PVD阈值或者低于阈值而产生边沿触发时，都会形成一次PVD中断，然后读取PWR_CSR的PVDO标志位检查是低电压提醒还是高电压提醒，以此来达到监控MCU供电情况的目的。</p>
<p>注意：当使用PVD功能检测低电压时，VDD电压刚刚小于阈值时并不会直接产生PVD中断，只有当VDD电压小于（阈值-50MV）时，才会产生中断。</p>
<p>如果有什么疑问或者错误欢迎大家指正，email:454626653@qq.com</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以帧为存储单位的循环stack存储结构的设计]]></title>
      <url>http://yoursite.com/2016/07/11/%E6%9E%84%E5%BB%BA%E4%BB%A5%E5%B8%A7%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84stack/</url>
      <content type="html"><![CDATA[<p>我的stack frame的src以及例程位于<a href="https://github.com/AnswerInTheWind/Data_Structure/tree/master/stack_FrameTest" target="_blank" rel="external">stack_FrameTest</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>为了配合项目的需要，我构造了一个循环的stack，stack是一种后进先出的存储结构，在实际中使用这种存储结构，可以使保证最新的数据拥有最高优先级。<br>在物联网的系统中，往往需要获取传感器的最新的状态，所以传输传感器的最新状态往往比传送之前的状态更有意义。</p>
<h2 id="stack构造及代码实现"><a href="#stack构造及代码实现" class="headerlink" title="stack构造及代码实现"></a>stack构造及代码实现</h2><p>其中我对stack以及frame的构造的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Frame</div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint8_t</span> frame_len;<span class="comment">//帧的字节数</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_data[MAX_TRANSMISSION_UINT];<span class="comment">//帧的存储空间</span></div><div class="line">&#125;Frame;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STACK</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int8_t</span> frame_lastNum;<span class="comment">//最近的帧的序号</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_count;<span class="comment">//stack中的帧的个数</span></div><div class="line">	Frame frame_info[MAX_STACK_FRAME_NUM];<span class="comment">//最多允许存储MAX_STACK_FRAME_NUM帧</span></div><div class="line">&#125;STACK;</div></pre></td></tr></table></figure></p>
<p>首先构造了一个stack，stack包含两个内容:</p>
<ol>
<li>stack的统计信息：stack中帧的个数，最新的帧的ID；</li>
<li>数据存储区,所有帧的数据存放区域；</li>
</ol>
<p>然后，帧的构造也包含了两个部分：</p>
<ol>
<li>此frame中的数据存储区中的有效数据的字节数；</li>
<li>数据存储区，此帧的数据存放区域；</li>
</ol>
<p>循环意味着此stack并非标准的stack，没有栈顶限制，当栈满了，仍然有数据进入时，数据从帧底开始存储，相当于栈底的原来的数据会被覆盖掉，也就没了栈越界的危险。</p>
<h2 id="此数据结构的优点"><a href="#此数据结构的优点" class="headerlink" title="此数据结构的优点"></a>此数据结构的优点</h2><ol>
<li>永远是最新的数据被最优先处理；</li>
<li>没有栈越界的危险，在嵌入式或者其他队稳定性要求较高的环境中，可靠，不会因为数据过多出现指针异常导致崩溃的情况出现；</li>
<li>在海量数据涌来但无法全部进行处理的时候，选择最新的数据保存，进行处理，保证了数据的实时性；</li>
</ol>
<h2 id="此数据结构也有明显的缺点"><a href="#此数据结构也有明显的缺点" class="headerlink" title="此数据结构也有明显的缺点"></a>此数据结构也有明显的缺点</h2><ol>
<li>如果处理速度慢，较早的未处理的数据被覆盖就再也无法找回了；</li>
<li>由于stack中frame的存储空间是静态分配的，而不是在运行时动态分配的，若frame的负载情况远远小于MTU，则会出现大量空间被浪费的情况；</li>
</ol>
<h2 id="拼包机制"><a href="#拼包机制" class="headerlink" title="拼包机制"></a>拼包机制</h2><p>在最后，此例程中还写了一个拼包的机制，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将stack中的数据进行拼包,在不造成断包的情况下最大限度地拼包</span></div><div class="line"><span class="keyword">uint8_t</span> SpliceFrame(<span class="keyword">uint8_t</span>* dest)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">		<span class="comment">//确保当前数据加下一帧数据不会超过最大单帧负载量(MTU)</span></div><div class="line">        <span class="keyword">if</span>((Splice_len +Stack_GetFrameLastNum()) &lt;= MAX_TRANSMISSION_UINT)</div><div class="line">        &#123;</div><div class="line">            Splice_len +=Stack_PopData(dest+Splice_len);<span class="comment">//</span></div><div class="line">            <span class="keyword">if</span>(Stack_GetFrameCount() == <span class="number">0</span>)<span class="comment">//当前融合帧的数量小于stack中已存帧的数量</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Splice_len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从程序中可见，此拼包的机制就是在MTU的限制内，在不造成断包的情况下，最大限度的地将stack中已经已有的数据包进行拼包，打包成一个较长的数据包进行处理。此拼包机制在无线网络中可以大大提高无线信道的传输效率。具体的测试情况可以查看源代码。</p>
<p>如果有什么疑问或者错误欢迎大家指正，欢迎大家评论或者提出issues.</p>
]]></content>
    </entry>
    
  
  
</search>
