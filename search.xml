<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LoRaWAN stack移植笔记(六)]]></title>
      <url>http://yoursite.com/2016/11/03/LoRaWAN%20stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0(%E5%85%AD)/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>调试的过程中碰到的问题基本都是以前没有遇到过的，而且需要对整个协议栈及射频方面的工作流程较熟悉才能找到问题的原因，需要多读SX1276的数据手册以及与射频芯片的物理层通信例程和MAC层通信例程进行对比相结合。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="发送失败"><a href="#发送失败" class="headerlink" title="发送失败"></a>发送失败</h3><p>LoRa 模块在进行 模式切换时,比如TX 切换到RX模式，需要先将设备切换到standby模式</p>
<h3 id="CRC-校验失败，然后程序陷入死循环"><a href="#CRC-校验失败，然后程序陷入死循环" class="headerlink" title="CRC 校验失败，然后程序陷入死循环"></a>CRC 校验失败，然后程序陷入死循环</h3><p>按逻辑来讲,CRC校验失败,应该进行的操作是吧校验失败的这个数据包丢弃，然后重启接收机(芯片每次接收完成都应该重启SX1276)</p>
<p>但是，程序一旦接收CRC校验失败就陷入循环，通过调试发现，原来是开启了一个定时器，定时时间为0，然后定时器的处理函数中又开启了此定时器，定时时间依旧没0，所以陷入了死循环。</p>
<p>这个定时器就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TimerStart( &amp;RxTimeoutSyncWord );</div></pre></td></tr></table></figure></p>
<p>在接收处理函数<strong>void SX1276OnDio0Irq( void )</strong> 中的CRC校验失败分支的处理代码中，以及定时器对应的处理函数<strong>void SX1276OnTimeoutIrq( void )</strong>中都开启了这个定时器。<br>如果是单个接收模式下，开启这个定时器并没有什么问题，但是在我调试的代码中，我开始的是连续接收模式，此模式根本没有同步字接收超时继续开着接收模式就可以了，并不需要特别的处理，可以不需要处理，<br>而官方SDK中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">void SX1276OnDio0Irq( void )</div><div class="line">&#123;</div><div class="line">	.........</div><div class="line">	if( SX1276.Settings.Fsk.CrcOn == true )</div><div class="line">	&#123;</div><div class="line">	    irqFlags = SX1276Read( REG_IRQFLAGS2 );</div><div class="line">	    if( ( irqFlags &amp; RF_IRQFLAGS2_CRCOK ) != RF_IRQFLAGS2_CRCOK )</div><div class="line">	    &#123;</div><div class="line">	        // Clear Irqs</div><div class="line">	        SX1276Write( REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |</div><div class="line">	                                    RF_IRQFLAGS1_PREAMBLEDETECT |</div><div class="line">	                                    RF_IRQFLAGS1_SYNCADDRESSMATCH );</div><div class="line">	        SX1276Write( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN );</div><div class="line">	</div><div class="line">	        TimerStop( &amp;RxTimeoutTimer );</div><div class="line">	</div><div class="line">	        if( SX1276.Settings.Fsk.RxContinuous == false )</div><div class="line">	        &#123;</div><div class="line">	            TimerStop( &amp;RxTimeoutSyncWord );</div><div class="line">	            SX1276.Settings.State = RF_IDLE;</div><div class="line">	        &#125;</div><div class="line">	        else</div><div class="line">	        &#123;</div><div class="line">	            // Continuous mode restart Rx chain</div><div class="line">	</div><div class="line">	          SX1276Write( REG_RXCONFIG, SX1276Read( REG_RXCONFIG ) | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK );</div><div class="line">	        &#125;</div><div class="line">	        </div><div class="line">	        if( ( RadioEvents != NULL ) &amp;&amp; ( RadioEvents-&gt;RxError != NULL ) )</div><div class="line">	        &#123;</div><div class="line">	            RadioEvents-&gt;RxError( );</div><div class="line">	        &#125;</div><div class="line">	        SX1276.Settings.FskPacketHandler.PreambleDetected = false;</div><div class="line">	        SX1276.Settings.FskPacketHandler.SyncWordDetected = false;</div><div class="line">	        SX1276.Settings.FskPacketHandler.NbBytes = 0;</div><div class="line">	        SX1276.Settings.FskPacketHandler.Size = 0;</div><div class="line">	        break;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	..........</div><div class="line">&#125;</div><div class="line"></div><div class="line">void SX1276OnTimeoutIrq( void )</div><div class="line">&#123;</div><div class="line">    switch( SX1276.Settings.State )</div><div class="line">    &#123;</div><div class="line">    case RF_RX_RUNNING:</div><div class="line">        if( SX1276.Settings.Modem == MODEM_FSK )</div><div class="line">        &#123;</div><div class="line">            SX1276.Settings.FskPacketHandler.PreambleDetected = false;</div><div class="line">            SX1276.Settings.FskPacketHandler.SyncWordDetected = false;</div><div class="line">            SX1276.Settings.FskPacketHandler.NbBytes = 0;</div><div class="line">            SX1276.Settings.FskPacketHandler.Size = 0;</div><div class="line"></div><div class="line">            // Clear Irqs</div><div class="line">            SX1276Write( REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |</div><div class="line">                                        RF_IRQFLAGS1_PREAMBLEDETECT |</div><div class="line">                                        RF_IRQFLAGS1_SYNCADDRESSMATCH );</div><div class="line">            SX1276Write( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN );</div><div class="line"></div><div class="line">            if( SX1276.Settings.Fsk.RxContinuous == true )</div><div class="line">            &#123;</div><div class="line">                // Continuous mode restart Rx chain</div><div class="line">                SX1276Write( REG_RXCONFIG, SX1276Read( REG_RXCONFIG ) | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK );</div><div class="line">                TimerStart( &amp;RxTimeoutSyncWord );</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                SX1276.Settings.State = RF_IDLE;</div><div class="line">                TimerStop( &amp;RxTimeoutSyncWord );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if( ( RadioEvents != NULL ) &amp;&amp; ( RadioEvents-&gt;RxTimeout != NULL ) )</div><div class="line">        &#123;</div><div class="line">            RadioEvents-&gt;RxTimeout( );</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">	................</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两处代码有着类似的才做，但是<code>RxTimeoutSyncWord</code>这个定时器会进入<code>void SX1276OnTimeoutIrq( void )</code>这个函数，而这个函数中又会重新开启<code>RxTimeoutSyncWord</code>这个定时器，导致死循环，所以在这里，应该讲两处的开启定时器的操作去掉（<code>TimerStart( &amp;RxTimeoutSyncWord );</code>），这样程序逻辑才正常。</p>
<h3 id="CRC-校验失败，然后在单步模式下，CRC一直失败"><a href="#CRC-校验失败，然后在单步模式下，CRC一直失败" class="headerlink" title="CRC 校验失败，然后在单步模式下，CRC一直失败"></a>CRC 校验失败，然后在单步模式下，CRC一直失败</h3><p>这个问题不是程序的问题，原因是因为我在单步模式下看CRC做接收，然后我的单步调试打断了射频芯片的正常工作。嗯、、就是这样，这个故事告诉我们，不要手贱。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN stack移植笔记(五)__杂七杂八的问题]]></title>
      <url>http://yoursite.com/2016/10/27/LoRaWAN%20stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0(%E4%BA%94)__%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="先废话一小段"><a href="#先废话一小段" class="headerlink" title="先废话一小段"></a>先废话一小段</h2><p>在将LoRaWAN的程序移植的过程中，调试发现了很多的问题。</p>
<p>做好记录工作，防止以后再踩坑</p>
<p>移植使用的是<a href="https://github.com/Lora-net/LoRaMac-node" target="_blank" rel="external">LoRaMac-node</a>库，使用的是STM32L151CBT6 MCU，需要要移植到STM32L051C8T6 这个MCU上面。</p>
<h2 id="开始正文"><a href="#开始正文" class="headerlink" title="开始正文"></a>开始正文</h2><h3 id="JLink的配置"><a href="#JLink的配置" class="headerlink" title="JLink的配置"></a>JLink的配置</h3><p>由于第一次使用JLink(SWD方式)，在一开始使用时，踩了几处坑：</p>
<ol>
<li>KEIL选择JLINK之后，点击设置进入，会出现一个对话框，要选择NO</li>
</ol>
<p><img src="../../../../uploads/LoRaWAN_STM32/JLINK_DEVICE_SELECTION.png" alt=""></p>
<ol>
<li><p>KEIL里面JLINK的 方式要选择SW，不然认不到芯片</p>
</li>
<li><p>Flash download要选择对应大小的芯片，注意Flash的大小要选择正确<br><img src="../../../../uploads/LoRaWAN_STM32/FLASH_DOWNLOAD.png" alt=""></p>
</li>
</ol>
<h3 id="程序无法进入main，甚至一个函数都没有跑"><a href="#程序无法进入main，甚至一个函数都没有跑" class="headerlink" title="程序无法进入main，甚至一个函数都没有跑"></a>程序无法进入main，甚至一个函数都没有跑</h3><p>当配置完JLink之后，程序可以正常烧写调试了，但是问题又出现了，无法跑进main函数，再进一步调试，发现来一个函数都没有执行，直接就进入进入死循环了(通过单步调试看上面的汇编代码)。这个现象就很奇怪了，以前也没有碰到过。<br>因为3.3V和GND是正常的，这样就算晶振有问题，也会执行程序到配置晶振才会出问题，而不是一句函数都没有执行。<br>后来顿悟，大概是BOOT0没接，仔细一看原理图，果然BOOT0是悬空的，飞线焊上之后，问题终于得到了解决。</p>
<pre><code>NOTE：画原理图时一定要主要，BOOT0一定要接地，这样程序才能正常从FLASH启动
</code></pre><h3 id="RTC定时链表的配置"><a href="#RTC定时链表的配置" class="headerlink" title="RTC定时链表的配置"></a>RTC定时链表的配置</h3><p>官方的库中使用了RTC来作为定时器来处理一些定时的事件，这也是库中唯一的任务调度机制。所以保证这个机制的正常运行非常重要。</p>
<p>但是，当我把一切参数都配置完成之后，却发现，RTC的定时器不听使唤，经常不进入中断，初步诊断是写入寄存器的定时时间出了问题，但是却找不到出问题的原因。</p>
<p>这个问题也是非常的诡异，至今还未发现原因。</p>
<p>但是在一次偶然的调试中，我将原本处于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RtcStartWakeUpAlarm</span><span class="params">( <span class="keyword">uint32_t</span> timeoutValue )</span></span></div></pre></td></tr></table></figure></p>
<p>这个函数中的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RtcCalendar_t now;</div><div class="line">RtcCalendar_t alarmTimer;</div><div class="line">RTC_AlarmTypeDef alarmStructure;</div></pre></td></tr></table></figure></p>
<p>这三个变量由局部变量改为了全局变量，问题就得到了解决。</p>
<p>但是原因还未发现。原本以为是变量未赋初值就使用，但是程序中都有在使用前赋初值，具体原因不明。</p>
<h3 id="程序进入Default-handler"><a href="#程序进入Default-handler" class="headerlink" title="程序进入Default_handler"></a>程序进入Default_handler</h3><p>在调试程序的时候，程序又出现跑死的情况，然后单步调试发现程序进入了Default_handler这里，始终无法跑出来。</p>
<p><strong>然后通过搜索得知，进入这里的情况应该是发生了中断但是没有处理，然后程序一直进入中断。</strong></p>
<p>后来查看代码发现，由于Cotex-M3和cotex-M0的核，对GPIO的中断的入口是不一样的，在移植时需要做修改，在做了修改之后，程序终于跑正常了。</p>
<h3 id="无法点对点通信"><a href="#无法点对点通信" class="headerlink" title="无法点对点通信"></a>无法点对点通信</h3><p>需要注意的是，点对点通信中，能够建立条件需要两个点的通信参数配置成相同。</p>
<p>特别注意的是<strong>iqInverted preamble SYNCWORD</strong></p>
<pre><code>note：
1. 如果发射方使能了iqInverted，那么接收方也要使能iqInverted    
2. 接收方的preambleLen必须设置大于发射方，否则有很大可能接收不到(偶尔可以收到，但是接收成功率很低)
3. 发射方和接收方的SYNCWORD必须设置一样(同步字一样)，否则认为是不同网络
</code></pre><p>接收机在接收检测时，会先检测前导码的长度，小于设置的最大接收长度时再检测同步字的内容，看是否一致，都符合时，才会接收负载的内容。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN__specification_数据收发机制]]></title>
      <url>http://yoursite.com/2016/10/20/LoRaWAN_ClassA_C_%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="终端数据发送"><a href="#终端数据发送" class="headerlink" title="终端数据发送"></a>终端数据发送</h2><p>由于LoRaWAN的gw具有49个LoRa的解调器，其配置成8通道，每个通道支持6种速度(DR0-DR5) 8*6 = 48</p>
<p>所以，只要在设置的8个通道内，以任何的速度发送都可以，只要满足占空比的要求即可。</p>
<h2 id="终端数据接收"><a href="#终端数据接收" class="headerlink" title="终端数据接收"></a>终端数据接收</h2><p>由于终端的射频芯片是半双工的，出于省电的考虑，LoRaWAN对终端的接收做了很多的规定(因为接收不是终端自主控制的，长时间的等待会增加终端的功耗)。</p>
<h3 id="CLASS-A-RX"><a href="#CLASS-A-RX" class="headerlink" title="CLASS A  RX"></a>CLASS A  RX</h3><p>在LoRaWAN specification中,关于Class A的描述如下<br><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_CLASSA_RX.png" alt=""></p>
<p>CLASS A的接收方式是LoRaWAN的三种接收方式中最省电的</p>
<p>终端在发送完上行数据之后，会开启两个接收窗口期，RX1 和 RX2 ，其中RX1会在发送完成之后RECEIVE_DELAY1(s)之后开启，RX2会在发送完成之后RECEIVE_DELAY2(S)之后开启。</p>
<p>RX1的接收频点和上行时用的发送频点相同，接收的速率和发送速率存在一定的映射关系。默认情况下,接收速率和上一次上行的速率是一样的。</p>
<p>RX2的接收频点和速率是固定的。也可以通过MAC COMMAND修改。</p>
<p>其中地区不同，默认的接收频点和速率也会不一样。</p>
<h3 id="CLASS-C-RX"><a href="#CLASS-C-RX" class="headerlink" title="CLASS C  RX"></a>CLASS C  RX</h3><p>CLASS C的设备除了在发送期间，其他时间都处于接收模式，也就是除了Transmit Time On Air 之外，几乎其他时间都是在接收。</p>
<p>接收的窗口和频点是RX2的接收串口和频点，是一个固定值。<br> <img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_CLASSC_RX.png" alt=""></p>
<p>由图可知，CLASS C的接收窗口是在CLASS A的基础上的，即在CLASS A的设备休眠时间打开RX2接收窗口：</p>
<ol>
<li>首先在RECEIVE_DELAY1这段时间里面打开接收窗口，而CLASS A的设备在这段时间里面是做休眠的，</li>
<li>然后RECEIVE_DELAY1之后打开RX1的接收窗口，再在设备发送完成过了RECEIVE_DELAY2(S)之后,打开RX2接收窗口，之后一直开着RX2的接收窗口，直到设备需要切换到发送状态。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN协议(二)__ADR]]></title>
      <url>http://yoursite.com/2016/10/17/LoRaWAN_specification_ADR/</url>
      <content type="html"><![CDATA[<h2 id="LoRaWAN-ADR机制"><a href="#LoRaWAN-ADR机制" class="headerlink" title="LoRaWAN ADR机制"></a>LoRaWAN ADR机制</h2><p>LoRa network allows the end-devices to individually use any of the possible data rates. This feature is used by the LoRaWAN to adapt and optimize the data rate of static end-devices. This is referred to as Adaptive Data Rate (ADR) and when this is enabled the network will be optimized to use the fastest data rate possible.</p>
<p>LoRa网络允许终端设备单独地使用任何可能的数据速率.LoRaWAN使用这个特性去匹配并且优化静态终端的数据速度。这个叫做自适应数据速率(ADR),并且当他使能的时候，网络可能被优化到最快的数据速率。</p>
<p>Mobile end-devices should use their fixed default data rate as data rate management is not practical when the moving end-device causes fast changes in the radio environment. </p>
<p>当设备处于移动中造成无线电环境快速变化时，移动终端设备应当使用固定的默认的数据速率，因为数据速率管理不是很靠谱。</p>
<p>If the ADR bit is set, the network will control the data rate of the end-device through the appropriate MAC commands. If the ADR bit is not set, the network will not attempt to control the data rate of the end-device regardless of the received signal quality. The ADR bit may be set and unset by the end-device or the Network on demand. However, whenever possible, the ADR scheme should be enabled to increase the battery life of the end-device and maximize the network capacity.</p>
<p>如果ADR位被设置了，网络会通过适当的MAC层命令来控制终端设备的数据速率。如果ADR位没有被设置，网络不管接收信号的质量如何都不会试图去控制终端设备的数据速率。ADR标志位应当被设置或者不设置根据终端或者网络的需求。然而，无论何时，只要可能，为了增加终端设备的电池使用时间并且最大化网络容量，ADR功能都应当使能。</p>
<p>Note: Even mobile end-devices are actually immobile most of the time. So depending on its state of mobility, an end-device can request the network to optimize its data rate using ADR.</p>
<p>注意：就算是移动终端设备，实际上大部分时间还是不移动的。所以，终端设备可以使用ADR，根据它的移动情况，请求网络来优化它的数据速率。</p>
<p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_ADR.png" alt=""></p>
<p>If an end-device whose data rate is optimized by the network to use a data rate higher than its default data rate, it periodically needs to validate that the network still receives the uplink frames. Each time the uplink frame counter is incremented (for each new uplink, repeated transmissions do not increase the counter), the device increments an ADR_ACK_CNT counter.<br>After ADR_ACK_LIMIT uplinks (ADR_ACK_CNT &gt;= ADR_ACK_LIMIT) without any downlink response, it sets the ADR acknowledgment request bit (ADRACKReq).<br>The network is required to respond with a downlink frame within the time set by the ADR_ACK_DELAY, any received downlink frame following an uplink frame resets the ADR_ACK_CNT counter.<br>The downlink ACK bit does not need to be set as any response during the receive slot of the end-device indicates that the gateway has still received the uplinks from this device.<br>If no reply is received within the next ADR_ACK_DELAY uplinks (i.e., after a total of ADR_ACK_LIMIT + ADR_ACK_DELAY), the end-device may try to regain connectivity by switching to the next lower data rate that provides a longer radio range.<br>The end-device will further lower its data rate step by step every time ADR_ACK_LIMIT is reached.<br>The ADRACKReq shall not be set if the device uses its default data rate because in that case no action can be taken to improve the link range.</p>
<p>如果终端设备的数据速率被网络优化到大于他的默认速率，那么他需要周期性地去验证网络是否一直收到上行数据帧。<br>上行数据帧计数器的每一次增长(每一次新的上行帧，重复性的传输不会增长计数器)，设备的ADR_ACK_CNT计数器增加。<br>当ADR_ACK_LIMIT上行帧(ADR_ACK_CNT &gt;= ADR_ACK_LIMIT)没有任何下行回复时,设备设置ADR acknowledgment 请求标志位(ADRACKReq)。<br>网络必须在设定的ADR_ACK_DELAY时间内回复一个下行帧，任何伴随着上行帧接收到的下行帧都会复位ADR_ACK_CNT计数器。<br>在设备的接收缝隙期间，任何回复的下行的ACK标志位不需要被设置来指示网关一直接收到这个设备的上行数据帧。<br>如果在接下来的ADR_ACK_DELAY个上行帧内没有收到回复(例如，在一整个ACR_ACK_LIMIT+ADR_ACK_DELAY)，设备会尝试回复链接通过切换到相邻的低一级的速度，因为那提供了更远的无线距离。<br>终端设备将会进一步的降低它的速率一步一步每当ADR_ACK_LIMIT的次数限制到达。<br>ADRACKReq不应该被设置如果设备使用默认的速率，因为在这种情况下，没有任何操作可以提高链接的范围。</p>
<p>Note: Not requesting an immediate response to an ADR acknowledgement request provides flexibility to the network to optimally schedule its downlinks.<br>注意: ADR ACK不要求立即回复，网络对他的下行帧提供了弹性的优化计划。</p>
<p>Note: In uplink transmissions the ADRACKReq bit is set if ADR_ACK_CNT &gt;= ADR_ACK_LIMIT and the current data-rate is greater than the device defined minimum data rate, it is cleared in other conditions.<br>注意：在上行的传输中，如果ADR_ACK_CNT&gt;=ADR_ACK_LIMIT并且当前的速率高于设备定义的最小速率，此时ADRACKReq标志位被设置，那么他会在其他情况下被清除掉。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN协议(一)__MAC Message Format]]></title>
      <url>http://yoursite.com/2016/10/17/LoRaWAN_specification_message_format/</url>
      <content type="html"><![CDATA[<h1 id="Radio-Message-amp-PHYPayload"><a href="#Radio-Message-amp-PHYPayload" class="headerlink" title="Radio Message &amp; PHYPayload"></a>Radio Message &amp; PHYPayload</h1><p>Radion PHY layer 是无线数据包的底层，PHYPayload开始就是LoRaWAN的数据协议封装<br><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_format.png" alt=""></p>
<p>可见PHYPayload是由三部分组成的。MHDR是MAC层的header，MACPayload是MAC层的负载部分，MIC是校验位(4个字节)</p>
<h2 id="MHDR"><a href="#MHDR" class="headerlink" title="MHDR"></a>MHDR</h2><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MHDR.png" alt=""></p>
<p>MHDR共一个字节，其中高3位表示消息类型，低2位表示协议的版本号，中间三个位保留</p>
<h3 id="MType"><a href="#MType" class="headerlink" title="MType"></a>MType</h3><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MType.png" alt=""></p>
<p>一共有8种，其中还是一种是预留的</p>
<h3 id="Major"><a href="#Major" class="headerlink" title="Major"></a>Major</h3><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_Major.png" alt=""></p>
<h2 id="MACPayload"><a href="#MACPayload" class="headerlink" title="MACPayload"></a>MACPayload</h2><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MACPayload.png" alt=""></p>
<p>其主要包含FHDR、FPort、FRMPayload</p>
<h3 id="FHDR"><a href="#FHDR" class="headerlink" title="FHDR"></a>FHDR</h3><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_FHDR.png" alt=""></p>
<p>DevAddr是设备的32位唯一ID，FCtrl存储的是帧的一些控制信息，包括ADR信息，ACK信息以及FOptsLen，FCnt是16位的数据帧的计数，FOpts存储的是数据控制命令的信息。</p>
<p>FOpts的控制命令有如下几种:</p>
<p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MAC_Commands.png" alt=""></p>
<h3 id="FPort"><a href="#FPort" class="headerlink" title="FPort"></a>FPort</h3><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MAC_FPort.png" alt=""></p>
<h3 id="FRMPayload"><a href="#FRMPayload" class="headerlink" title="FRMPayload"></a>FRMPayload</h3><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MAC_FRMPayload.png" alt=""></p>
<p>FRMPayload是数据帧的负载部分，其负载会使用AES128加密，所以在传输的过程中看不到负载的本身。</p>
<p>需要注意的是FRMPayload需要在计算MIC之前进行加密。</p>
<h2 id="MIC"><a href="#MIC" class="headerlink" title="MIC"></a>MIC</h2><p><img src="../../../../uploads/LoRaWAN_STM32/LoRaWAN_message_MIC.png" alt=""></p>
<p>MIC是数据帧的32位校验位，其中参与校验的是MHDR、FHDR、FPort、FRMPayload。</p>
<p>校验的方法如上如所示，使用的是AES128加密算法，在计算完成之后取出前4个字节。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN_stack移植笔记(四)__RTC]]></title>
      <url>http://yoursite.com/2016/10/14/LoRaWAN_stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0%20(%E5%9B%9B)__RTC/</url>
      <content type="html"><![CDATA[<h1 id="stm32相关的配置"><a href="#stm32相关的配置" class="headerlink" title="stm32相关的配置"></a>stm32相关的配置</h1><p>由于例程使用的主控芯片为STM32L151C8T6,而在本设计中使用的主控芯片为STM32L051C8T6，内核不一样，并且Cube库相关的函数接口及配置也会有不同，所以芯片的驱动所以做修改。</p>
<h2 id="RTC-的配置"><a href="#RTC-的配置" class="headerlink" title="RTC 的配置"></a>RTC 的配置</h2><p>此例程中，RTC被当做定时器使用，用于定时执行任务。</p>
<p>例程中，RTC使用外部LSE的32.768Khz的晶振作为时钟源，<br>而在本设计中，使用内部LSI作为RTC的时钟源，需要重新设置RTC的分频参数，使得程序正常运行。</p>
<p>根据Fck_spre = Frtcclk/(PREDIV_S+1)/(PREDIV_A+1)<br>例程中RTC的工作频率为32.778/(3+1)/(3+1) = 2.048Khz,</p>
<p>而内部晶振的频率约为37Khz，故PRVEDIV_S和PREDIV_A的值需要改变。</p>
<pre><code>37/2.048 ~= 18；
数据手册里面有这样一句话：    
Note: When both prescalers are used, it is recommended to configure the asynchronous 
prescaler to a high value to minimize consumption.
所以：18 = 9*2；故设置PREDIV_A = 8，PREDIV_S = 1;
</code></pre><p>由于<br>    37/18 ~= 2.055<br>    1/2.055 ~= 0.486618</p>
<p>故此处的宏定义需要稍作修改<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*!</span></div><div class="line"> * RTC Time base in ms</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_DURATION                     0.486618      <span class="comment">// 1 tick every 466us</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_PER_MS                       2.055           <span class="comment">// 1/2.055 = tick duration in ms ((37/(8+1)/(2+1)) = 2.055Khz)</span></span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN_stack移植笔记(三)__SPI]]></title>
      <url>http://yoursite.com/2016/10/14/LoRaWAN_stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0%20(%E4%B8%89)__SPI/</url>
      <content type="html"><![CDATA[<h1 id="stm32相关的配置"><a href="#stm32相关的配置" class="headerlink" title="stm32相关的配置"></a>stm32相关的配置</h1><p>由于例程使用的主控芯片为STM32L151C8T6,而在本设计中使用的主控芯片为STM32L051C8T6，内核不一样，并且Cube库相关的函数接口及配置也会有不同，所以芯片的驱动所以做修改。</p>
<h2 id="SPI-的配置"><a href="#SPI-的配置" class="headerlink" title="SPI 的配置"></a>SPI 的配置</h2><p>SPI使用的是STM32的硬件接口-SPI1 MOSI MISO<br>可以看到例程中，对SPI接口进行了再一层的封装，封装如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"> * SPI driver structure definition</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> Spi_s</div><div class="line">&#123;</div><div class="line">    SPI_HandleTypeDef Spi;</div><div class="line">    Gpio_t Mosi;</div><div class="line">    Gpio_t Miso;</div><div class="line">    Gpio_t Sclk;</div><div class="line">    Gpio_t Nss;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SPI_HandleTypeDef Spi;</div></pre></td></tr></table></figure></p>
<p>是原先的STM32Cube库的封装，在此基础上，将SPI的引脚也封装进了自定义的Spi_s结构体中。这样，查看结构体就可以看到SPI的所有情况。</p>
<h3 id="SPI-初始化配置"><a href="#SPI-初始化配置" class="headerlink" title="SPI 初始化配置"></a>SPI 初始化配置</h3><p>初始化的函数体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpiInit</span><span class="params">( Spi_t *obj, PinNames mosi, PinNames miso, PinNames sclk, PinNames nss )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="number">__</span>HAL_RCC_SPI1_FORCE_RESET( );</div><div class="line">    <span class="number">__</span>HAL_RCC_SPI1_RELEASE_RESET( );</div><div class="line"></div><div class="line">    <span class="number">__</span>HAL_RCC_SPI1_CLK_ENABLE( );</div><div class="line"></div><div class="line">    obj-&gt;Spi.Instance = ( SPI_TypeDef *) SPI1_BASE;</div><div class="line"></div><div class="line">    GpioInit( &amp;obj-&gt;Mosi, mosi, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_DOWN, GPIO_AF0_SPI1 );</div><div class="line">    GpioInit( &amp;obj-&gt;Miso, miso, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_DOWN, GPIO_AF0_SPI1 );</div><div class="line">    GpioInit( &amp;obj-&gt;Sclk, sclk, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_DOWN, GPIO_AF0_SPI1 );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( nss != NC )</div><div class="line">    &#123;</div><div class="line">        GpioInit( &amp;obj-&gt;Nss, nss, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_UP, GPIO_AF0_SPI1 );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        obj-&gt;Spi.Init.NSS = SPI_NSS_SOFT;</div><div class="line">			  GpioInit( &amp;SX1276.Spi.Nss, RADIO_NSS, PIN_OUTPUT, PIN_PUSH_PULL, PIN_PULL_UP, <span class="number">1</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( nss == NC )</div><div class="line">    &#123;</div><div class="line">        SpiFormat( obj, SPI_DATASIZE_8BIT, SPI_POLARITY_LOW, SPI_PHASE_1EDGE, <span class="number">0</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        SpiFormat( obj, SPI_DATASIZE_8BIT, SPI_POLARITY_LOW, SPI_PHASE_1EDGE, <span class="number">1</span> );</div><div class="line">    &#125;</div><div class="line">		obj-&gt;Spi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;</div><div class="line"></div><div class="line">    HAL_SPI_Init( &amp;obj-&gt;Spi );</div><div class="line">&#125;</div><div class="line">``` c</div><div class="line">SPI的初始化函数是这样被调用的：</div><div class="line">``` <span class="function">c</span></div><div class="line"><span class="title">SpiInit</span><span class="params">( &amp;SX1276.Spi, RADIO_MOSI, RADIO_MISO,RADIO_SCLK, NC )</span>;</div><div class="line"></div><div class="line"><span class="comment">//初始化函数的原型</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpiInit</span><span class="params">( Spi_t *obj, PinNames mosi, PinNames miso, PinNames sclk, PinNames nss )</span></span>;</div></pre></td></tr></table></figure></p>
<p>其中引脚定义是这样的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIO_MOSI                                PA_7</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIO_MISO                                PA_6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIO_SCLK                                PA_5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIO_NSS                                 PA_4</span></div></pre></td></tr></table></figure></p>
<p>可以看到SPI的MOSI/MISO/SCLK脚都有看到，但是NSS脚看到，而是传了NC。</p>
<p>这是为什么呢？<br>可以看到程序里面有段话<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( nss != NC )</div><div class="line">&#123;</div><div class="line">    GpioInit( &amp;obj-&gt;Nss, nss, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_UP, GPIO_AF0_SPI1 );</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    obj-&gt;Spi.Init.NSS = SPI_NSS_SOFT;</div><div class="line">	GpioInit( &amp;SX1276.Spi.Nss, RADIO_NSS, PIN_OUTPUT, PIN_PUSH_PULL, PIN_PULL_UP, <span class="number">1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其意思就是设置为NC就配置NSS 为软件控制，即NSS脚只做片选使用，x像GPIO一样控制他拉高拉低就可以控制片选的使能与否了。</p>
<p>还有一处，设置SPI的工作频率的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">SpiFrequency( obj, <span class="number">10000000</span> );</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpiFrequency</span><span class="params">( Spi_t *obj, <span class="keyword">uint32_t</span> hz )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint32_t</span> divisor;</div><div class="line"></div><div class="line">    divisor = SystemCoreClock / hz;</div><div class="line"></div><div class="line">    <span class="comment">// Find the nearest power-of-2</span></div><div class="line">    divisor = divisor &gt; <span class="number">0</span> ? divisor<span class="number">-1</span> : <span class="number">0</span>;</div><div class="line">    divisor |= divisor &gt;&gt; <span class="number">1</span>;</div><div class="line">    divisor |= divisor &gt;&gt; <span class="number">2</span>;</div><div class="line">    divisor |= divisor &gt;&gt; <span class="number">4</span>;</div><div class="line">    divisor |= divisor &gt;&gt; <span class="number">8</span>;</div><div class="line">    divisor |= divisor &gt;&gt; <span class="number">16</span>;</div><div class="line">    divisor++;</div><div class="line"></div><div class="line">    divisor = <span class="number">__f</span>fs( divisor ) - <span class="number">1</span>;</div><div class="line"></div><div class="line">    divisor = ( divisor &gt; <span class="number">0x07</span> ) ? <span class="number">0x07</span> : divisor;</div><div class="line"></div><div class="line">    obj-&gt;Spi.Init.BaudRatePrescaler = divisor &lt;&lt; <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<strong>ffs这个函数只有Cotex-M3以上内核才能调用，但是通过计算可知若传参为10000000,</strong>ffs这个函数的返回值为0x03,所以可得obj-&gt;Spi.Init.BaudRatePrescaler = 8，即SPI_BAUDRATEPRESCALER_8<br>因为<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define SPI_BAUDRATEPRESCALER_8         ((uint32_t)SPI_CR1_BR_1)</div><div class="line">#define SPI_CR1_BR_1                (0x2U &lt;&lt; SPI_CR1_BR_Pos)                   </div><div class="line">#define SPI_CR1_BR_Pos              (3U)</div></pre></td></tr></table></figure></p>
<p>所以此处设置Spi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;<br>最后再调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HAL_SPI_Init( &amp;obj-&gt;Spi );</div></pre></td></tr></table></figure></p>
<p>至此，SPI的初始化就完成了。</p>
<h3 id="SPI-读写"><a href="#SPI-读写" class="headerlink" title="SPI 读写"></a>SPI 读写</h3><p>接下来就是SPI的读写操作了，由于都是使用的Cube库，对寄存器的命名并没有什么不同，直接保留例程中的代码就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取SPI的标志位状态</span></div><div class="line"><span class="function">FlagStatus <span class="title">SpiGetFlag</span><span class="params">( Spi_t *obj, <span class="keyword">uint16_t</span> flag )</span></span></div><div class="line">&#123;</div><div class="line">    FlagStatus bitstatus = RESET;</div><div class="line"></div><div class="line">    <span class="comment">// Check the status of the specified SPI flag</span></div><div class="line">    <span class="keyword">if</span>( ( obj-&gt;Spi.Instance-&gt;SR &amp; flag ) != ( <span class="keyword">uint16_t</span> )RESET )</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// SPI_I2S_FLAG is set</span></div><div class="line">        bitstatus = SET;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// SPI_I2S_FLAG is reset</span></div><div class="line">        bitstatus = RESET;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Return the SPI_I2S_FLAG status</span></div><div class="line">    <span class="keyword">return</span>  bitstatus;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//SPI读写</span></div><div class="line"><span class="keyword">uint16_t</span> SpiInOut( Spi_t *obj, <span class="keyword">uint16_t</span> outData )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> rxData = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( ( obj == <span class="literal">NULL</span> ) || ( obj-&gt;Spi.Instance ) == <span class="literal">NULL</span> )</div><div class="line">    &#123;</div><div class="line">        assert_param( FAIL );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="number">__</span>HAL_SPI_ENABLE( &amp;obj-&gt;Spi );</div><div class="line"></div><div class="line">    <span class="keyword">while</span>( SpiGetFlag( obj, SPI_FLAG_TXE ) == RESET );</div><div class="line">    obj-&gt;Spi.Instance-&gt;DR = ( <span class="keyword">uint16_t</span> ) ( outData &amp; <span class="number">0xFF</span> );</div><div class="line"></div><div class="line">    <span class="keyword">while</span>( SpiGetFlag( obj, SPI_FLAG_RXNE ) == RESET );</div><div class="line">    rxData = ( <span class="keyword">uint16_t</span> ) obj-&gt;Spi.Instance-&gt;DR;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>( rxData );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用上，需要注意NSS引脚的操作，在进行读写前进行使能，读写完毕之后失能。程序如下图所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SPI写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276WriteBuffer</span><span class="params">( <span class="keyword">uint8_t</span> addr, <span class="keyword">uint8_t</span> *buffer, <span class="keyword">uint8_t</span> size )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> i;</div><div class="line"></div><div class="line">    <span class="comment">//NSS = 0;</span></div><div class="line">    GpioWrite( &amp;SX1276.Spi.Nss, <span class="number">0</span> );</div><div class="line"></div><div class="line">    SpiInOut( &amp;SX1276.Spi, addr | <span class="number">0x80</span> );</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size; i++ )</div><div class="line">    &#123;</div><div class="line">        SpiInOut( &amp;SX1276.Spi, buffer[i] );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//NSS = 1;</span></div><div class="line">    GpioWrite( &amp;SX1276.Spi.Nss, <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//SPI读</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276ReadBuffer</span><span class="params">( <span class="keyword">uint8_t</span> addr, <span class="keyword">uint8_t</span> *buffer, <span class="keyword">uint8_t</span> size )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> i;</div><div class="line"></div><div class="line">    <span class="comment">//NSS = 0;</span></div><div class="line">    GpioWrite( &amp;SX1276.Spi.Nss, <span class="number">0</span> );</div><div class="line"></div><div class="line">    SpiInOut( &amp;SX1276.Spi, addr &amp; <span class="number">0x7F</span> );</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size; i++ )</div><div class="line">    &#123;</div><div class="line">        buffer[i] = SpiInOut( &amp;SX1276.Spi, <span class="number">0</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//NSS = 1;</span></div><div class="line">    GpioWrite( &amp;SX1276.Spi.Nss, <span class="number">1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，LoRaWAN例程中的SPI的移植就完成了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN_stack移植笔记 (二)_GPIO]]></title>
      <url>http://yoursite.com/2016/10/14/LoRaWAN_stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0%20(%E4%BA%8C)_GPIO/</url>
      <content type="html"><![CDATA[<h1 id="stm32相关的配置"><a href="#stm32相关的配置" class="headerlink" title="stm32相关的配置"></a>stm32相关的配置</h1><p>由于例程使用的主控芯片为STM32L151C8T6,而在本设计中使用的主控芯片为STM32L051C8T6，内核不一样，并且Cube库相关的函数接口及配置也会有不同，所以芯片的驱动所以做修改。另外例程中对STM32库函数的再一次封装的方法也非常值得学习。</p>
<h2 id="GPIO-的配置"><a href="#GPIO-的配置" class="headerlink" title="GPIO 的配置"></a>GPIO 的配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GpioInit( &amp;obj-&gt;Tx, tx, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_UP, GPIO_AF0_USART1 );</div></pre></td></tr></table></figure>
<p>例程中可以看到，对IO口的初始化只有这一句，是因为例程中对GPIO的操作进行了封装，方便了上层的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"> * Board GPIO pin names</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">&#123;</div><div class="line">    MCU_PINS,</div><div class="line">    IOE_PINS,</div><div class="line"></div><div class="line">    <span class="comment">// Not connected</span></div><div class="line">    NC = (<span class="keyword">int</span>)<span class="number">0xFFFFFFFF</span></div><div class="line">&#125;PinNames;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line"> * STM32 Pin Names</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MCU_PINS \</span></div><div class="line">    PA_0 = 0, PA_1, PA_2, PA_3, PA_4, PA_5, PA_6, PA_7, PA_8, PA_9, PA_10, PA_11, PA_12, PA_13, PA_14, PA_15, \</div><div class="line">    PB_0, PB_1, PB_2, PB_3, PB_4, PB_5, PB_6, PB_7, PB_8, PB_9, PB_10, PB_11, PB_12, PB_13, PB_14, PB_15,     \</div><div class="line">    PC_0, PC_1, PC_2, PC_3, PC_4, PC_5, PC_6, PC_7, PC_8, PC_9, PC_10, PC_11, PC_12, PC_13, PC_14, PC_15,     \</div><div class="line">    PD_0, PD_1, PD_2, PD_3, PD_4, PD_5, PD_6, PD_7, PD_8, PD_9, PD_10, PD_11, PD_12, PD_13, PD_14, PD_15,     \</div><div class="line">    PE_0, PE_1, PE_2, PE_3, PE_4, PE_5, PE_6, PE_7, PE_8, PE_9, PE_10, PE_11, PE_12, PE_13, PE_14, PE_15,     \</div><div class="line">    PF_0, PF_1, PF_2, PF_3, PF_4, PF_5, PF_6, PF_7, PF_8, PF_9, PF_10, PF_11, PF_12, PF_13, PF_14, PF_15,     \</div><div class="line">    PH_0, PH_1, PH_2, PH_3, PH_4, PH_5, PH_6, PH_7, PH_8, PH_9, PH_10, PH_11, PH_12, PH_13, PH_14, PH_15</div></pre></td></tr></table></figure>
<p>例程中使用Enum定义了64个IO口，其中</p>
<ul>
<li>0-15 表示PA0-15</li>
<li>16-31表示PB0-15</li>
<li>32-47表示PC0-15</li>
<li>48-63表示PD0-15</li>
<li>64-79表示PE0-15</li>
<li>80-95表示PF0-15</li>
<li>96-111表示PH0-15</li>
</ul>
<p>这样，在定义引脚的时候直接是用Enum变量就可以表示出IO的PIN以及PORT，在完成驱动程序之后，操作引脚非常的方便。</p>
<p>例如 使用了一个LED灯，连接的是PB_5，这样我们#define LED PB_5，在程序里面就可以得知使用的是PB口，以及PIN_5，方法如下：</p>
<pre><code>由于PB_5 = 16+5 = 21;
21/16 = 1，得知使用的是PB口，21%16 = 5,得知使用的是PIN_5。
</code></pre><p>其中C语言的时下代码如下，使用(&amp;0xff)以及&lt;&lt;的操作，效率比做除法及取模的效率更高<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GpioMcuInit</span><span class="params">( Gpio_t *obj, PinNames pin, PinModes mode, PinConfigs config, PinTypes type, <span class="keyword">uint32_t</span> value )</span></span></div><div class="line">&#123;</div><div class="line">    GPIO_InitTypeDef GPIO_InitStructure;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( pin == NC )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    obj-&gt;pin = pin;</div><div class="line">    obj-&gt;pinIndex = ( <span class="number">0x01</span> &lt;&lt; ( obj-&gt;pin &amp; <span class="number">0x0F</span> ) );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( ( obj-&gt;pin &amp; <span class="number">0xF0</span> ) == <span class="number">0x00</span> )</div><div class="line">    &#123;</div><div class="line">        obj-&gt;port = GPIOA;</div><div class="line">        <span class="number">__</span>HAL_RCC_GPIOA_CLK_ENABLE( );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( ( obj-&gt;pin &amp; <span class="number">0xF0</span> ) == <span class="number">0x10</span> )</div><div class="line">    &#123;</div><div class="line">        obj-&gt;port = GPIOB;</div><div class="line">        <span class="number">__</span>HAL_RCC_GPIOB_CLK_ENABLE( );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( ( obj-&gt;pin &amp; <span class="number">0xF0</span> ) == <span class="number">0x20</span> )</div><div class="line">    &#123;</div><div class="line">        obj-&gt;port = GPIOC;</div><div class="line">        <span class="number">__</span>HAL_RCC_GPIOC_CLK_ENABLE( );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( ( obj-&gt;pin &amp; <span class="number">0xF0</span> ) == <span class="number">0x30</span> )</div><div class="line">    &#123;</div><div class="line">        obj-&gt;port = GPIOD;</div><div class="line">        <span class="number">__</span>HAL_RCC_GPIOD_CLK_ENABLE( );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        obj-&gt;port = GPIOH;</div><div class="line">        <span class="number">__</span>HAL_RCC_GPIOH_CLK_ENABLE( );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    GPIO_InitStructure.Pin =  obj-&gt;pinIndex ;</div><div class="line">    GPIO_InitStructure.Pull = type;</div><div class="line">    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( mode == PIN_INPUT )</div><div class="line">    &#123;</div><div class="line">        GPIO_InitStructure.Mode = GPIO_MODE_INPUT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( mode == PIN_ANALOGIC )</div><div class="line">    &#123;</div><div class="line">        GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( mode == PIN_ALTERNATE_FCT )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( config == PIN_OPEN_DRAIN )</div><div class="line">        &#123;</div><div class="line">            GPIO_InitStructure.Mode = GPIO_MODE_AF_OD;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;</div><div class="line">        &#125;</div><div class="line">        GPIO_InitStructure.Alternate = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="comment">// mode ouptut</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( config == PIN_OPEN_DRAIN )</div><div class="line">        &#123;</div><div class="line">            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_OD;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HAL_GPIO_Init( obj-&gt;port, &amp;GPIO_InitStructure );</div><div class="line"></div><div class="line">    <span class="comment">// Sets initial output value</span></div><div class="line">    <span class="keyword">if</span>( mode == PIN_OUTPUT )</div><div class="line">    &#123;</div><div class="line">        GpioMcuWrite( obj, value );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32_NVIC设置]]></title>
      <url>http://yoursite.com/2016/10/13/STM32_NVIC%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置中断的抢占优先级</span></div><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">INLINE <span class="keyword">void</span> <span class="title">NVIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="keyword">uint32_t</span> priority)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//使能中断</span></div><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">INLINE <span class="keyword">void</span> <span class="title">NVIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//设置优先级组</span></div><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">INLINE <span class="keyword">void</span> <span class="title">NVIC_SetPriorityGrouping</span><span class="params">(<span class="keyword">uint32_t</span> PriorityGroup)</span></span>;</div></pre></td></tr></table></figure>
<p>常用的配置中断优先级的函数就是三个，其中最常用的就是两个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">INLINE <span class="keyword">void</span> <span class="title">NVIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="keyword">uint32_t</span> priority)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">INLINE <span class="keyword">void</span> <span class="title">NVIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span>;</div></pre></td></tr></table></figure></p>
<p>因为NVIC默认就是是组4，可以不用设置，即四位抢占优先级，0位响应优先级<br><img src="../../../../uploads/LoRaWAN_STM32/STM32_NVIC.png" alt=""></p>
<h2 id="优先级冲突的处理"><a href="#优先级冲突的处理" class="headerlink" title="优先级冲突的处理"></a>优先级冲突的处理</h2><ul>
<li>具有高抢占式优先级的中断可以在具有低抢占式优先级的中断处理过程中被响应，即中断的嵌套，或者说高抢占式优先级的中断可以嵌套低抢占式优先级的中断；</li>
<li>当两个中断源的抢占式优先级相同时，这两个中断将没有嵌套关系，当一个中断到来后，如果正在处理另一个中断，这个后到来的中断就要等到前一个中断处理完之后才能被处理。如果这个两个中断同时到达，则中断控制器根据他们的响应优先级高低来决定先处理哪一个；</li>
<li>如果他们的抢占式优先级和响应优先级都相等，则根据他们在中断表中的排位顺序决定先处理哪一个；</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>例如:<br>NVIC_SetPriority(UART1_IRQn,2);</p>
<p>NVIC_EnableIRQ(UART1_IRQn);</p>
<p>NVIC_SetPriority(UART0_IRQn,9);<br>NVIC_EnableIRQ(UART0_IRQn);<br>设置UART1_IRQn的优先级为2，UART0_IRQn的优先级为9，并且使能中断。</p>
<p>其中，抢占优先级的数字越低，优先级越高</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN_stack移植笔记(一)--RF硬件相关]]></title>
      <url>http://yoursite.com/2016/10/11/LoRaWAN_stack%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0(%E4%B8%80)_RF%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="和硬件相关的问题"><a href="#和硬件相关的问题" class="headerlink" title="和硬件相关的问题"></a>和硬件相关的问题</h2><h3 id="TCXO-的使用"><a href="#TCXO-的使用" class="headerlink" title="TCXO 的使用"></a>TCXO 的使用</h3><p>根据SX1276数据手册，<br><img src="../../../../uploads/LoRaWAN_STM32/REGTCXO.png" alt=""></p>
<ul>
<li><p>如果使用TCXO,则需要配置RegTcxo寄存器为0x19,代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276SetTcxoConfig</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//此函数为自定义的</span></span></div><div class="line">&#123;</div><div class="line">  SX1276Write( REG_TCXO, <span class="number">0x19</span> ); <span class="comment">//设置TCXO  </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在初始化中调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276Init</span><span class="params">( RadioEvents_t *events )</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	SX1276SetTcxoConfig();</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>否则配置为0x09,因为芯片上电默认不使用TCXO，即上电寄存器值即为0x09,所以无需配置</p>
</li>
</ul>
<h3 id="PA-BOOST-引脚的使用"><a href="#PA-BOOST-引脚的使用" class="headerlink" title="PA_BOOST 引脚的使用"></a>PA_BOOST 引脚的使用</h3><p>根据sx1276 数据手册<br><img src="../../../../uploads/LoRaWAN_STM32/REGPACONFIG.png" alt=""></p>
<ul>
<li>如果使用PA_BOOST作为RF输出，则需要配置PaSelect脚为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276SetTxConfig</span><span class="params">(......)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	paConfig = ( paConfig &amp; RF_PACONFIG_PASELECT_MASK ) | SX1276GetPaSelect( SX1276.Settings.Channel );<span class="comment">//选择是否使用PA_BOOST引脚</span></div><div class="line">	...</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//根据具体的电路图不一样，此函数也会币一样，比如低频使用PA_BOOST，高频使用RFO_HF，则函数体如下</span></div><div class="line"><span class="keyword">uint8_t</span> SX1276GetPaSelect( <span class="keyword">uint32_t</span> channel )</div><div class="line">&#123;</div><div class="line">	<span class="comment">//如果是低频的，使用PA_BOOST，高频使用RFO_HF</span></div><div class="line">    <span class="keyword">if</span>( channel &lt; RF_MID_BAND_THRESH )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_PABOOST;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_RFO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果高低频都使用PA_BOOST，则函数体如下</span></div><div class="line"><span class="keyword">uint8_t</span> SX1276GetPaSelect( <span class="keyword">uint32_t</span> channel )</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> RF_PACONFIG_PASELECT_PABOOST; </div><div class="line">&#125;</div><div class="line"><span class="comment">//如果高频使用PA_BOOST，低频使用RFO_LF，则函数体如下</span></div><div class="line"><span class="keyword">uint8_t</span> SX1276GetPaSelect( <span class="keyword">uint32_t</span> channel )</div><div class="line">&#123;</div><div class="line">	<span class="comment">//如果是高频的，使用PA_BOOST，低频使用RFO_LF</span></div><div class="line">    <span class="keyword">if</span>( channel &gt; RF_MID_BAND_THRESH )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_PABOOST;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> RF_PACONFIG_PASELECT_RFO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line">* RegPaConfig</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_PACONFIG_PASELECT_MASK                   0x7F</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_PACONFIG_PASELECT_PABOOST                0x80</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_PACONFIG_PASELECT_RFO                    0x00 <span class="comment">// Default</span></span></div></pre></td></tr></table></figure>
<ul>
<li>否则为0</li>
</ul>
<h3 id="RXTX-switch-接收和发送的天线电路的切换"><a href="#RXTX-switch-接收和发送的天线电路的切换" class="headerlink" title="RXTX switch(接收和发送的天线电路的切换)"></a>RXTX switch(接收和发送的天线电路的切换)</h3><p><img src="../../../../uploads/LoRaWAN_STM32/TXRX.png" alt=""><br>在图中可以看到，射频输入和射频输出是不一样的电路，但是用的是一个天线，所以用到了一个射频电路切换的芯片。<br>在程序中，需要做的就是控制FEM_CPS脚，在RX和TX时进行RF1(RFI)和RF2(RFO)的切换。<br>由于在设计中兼容高低频，并且使用两个引脚分别控制高频和低频部分的射频部分输入输出的切换，所以在实际使用中需要控制两个引脚。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SX1276SetAntSw</span><span class="params">( <span class="keyword">uint8_t</span> rxTx )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( rxTx != <span class="number">0</span> ) <span class="comment">// 1: TX, 0: RX</span></div><div class="line">    &#123;</div><div class="line">        GpioWrite( &amp;AntSwitchLf, <span class="number">0</span> );<span class="comment">//切换到低频发射电路</span></div><div class="line">        GpioWrite( &amp;AntSwitchHf, <span class="number">1</span> );<span class="comment">//切换到高频发射电路</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        GpioWrite( &amp;AntSwitchLf, <span class="number">1</span> );<span class="comment">//切换到低频接收电路</span></div><div class="line">        GpioWrite( &amp;AntSwitchHf, <span class="number">0</span> );<span class="comment">//切换到高频接收电路 </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果只有高频或者低频一个部分，上面的代码只要保留相应的部分即可</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32时钟配置--系统时钟、RTC时钟、IWDG时钟]]></title>
      <url>http://yoursite.com/2016/10/11/STM32%E6%97%B6%E9%92%9F%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="stm32L0x1的时钟分类"><a href="#stm32L0x1的时钟分类" class="headerlink" title="stm32L0x1的时钟分类"></a>stm32L0x1的时钟分类</h1><p><img src="../../../../uploads/LoRaWAN_STM32/STM32_OSC.png" alt=""><br>先给大家推荐一个软件STM32CubeMX，上面的那张关于时钟的图就是从这个软件中截图得来的，这个软件还可以查看配置的时钟情况以及时钟树，挺方便的。</p>
<p>从图上，可以看出，STM32的始终源一共有HSE、HSI、LSE、LSI、MSI、PLL六种，<br>其中</p>
<ul>
<li>HSE是外部的高速晶振，可以直接使用或者通过PLL倍频,最终输出不能超过32Mhz</li>
<li>HSI是内部的高速RC振荡器，频率为16Mhz，可以直接使用或者通过PLL倍频,最终输出不能超过32Mhz</li>
<li>LSE是外部的低速晶振，可以用于RTC或者IWDG，频率为32.768KH在</li>
<li>LSI是内部的低速RC振荡器，频率约为37KHz</li>
<li>MSI是内部的RC振荡器，其频率编程可调</li>
<li>PLL是一个锁相环，可以将HSE或HSI倍频之后再给系统提供时钟。</li>
</ul>
<p>其中注意的是，内部时钟的精度都比较差,在对时钟要求比较高的场合,建议使用外部晶振</p>
<h2 id="系统时钟源"><a href="#系统时钟源" class="headerlink" title="系统时钟源"></a>系统时钟源</h2><p><img src="../../../../uploads/LoRaWAN_STM32/STM32_OSC_SYSTEM.png" alt=""><br>从图中可以看到，系统时钟的选择有</p>
<ul>
<li>MSI(65.536 kHz, 131.072 kHz, 262.144 kHz, 524.288 kHz, 1.048 MHz,<br>2.097 MHz (default value) and 4.194 MHz)</li>
<li>HSI(16,16/4)</li>
<li>HSE(1-24MHz)</li>
<li>PLLCLK(HSE/HSI倍频锁相环)</li>
</ul>
<p>其中PLLCLK是比较常用的一种，可以将HSE或HSI(HSI/4)倍频，然后再给主系统提供时钟。<br>其计算公式为PLLCLK_OUT = (PLLCLK_SOURCE * PLLMUL / PLLDIV);</p>
<p>例如要给系统提供32MHz的晶振，可以</p>
<ul>
<li>HSI(16) * 4(PLLMUL) / 2(PLLDIV)</li>
<li>HSE(12) * 8(PLLMUL) / 3(PLLDIV)</li>
</ul>
<p>以上两种方法只是举个例子，倍频的方法并不是固定的。</p>
<p>注意，实际使用中，这四个时钟源只能同时选择一个，不能同时选择多个。</p>
<h2 id="RTC时钟源-IWDG-时钟源"><a href="#RTC时钟源-IWDG-时钟源" class="headerlink" title="RTC时钟源  IWDG 时钟源"></a>RTC时钟源  IWDG 时钟源</h2><p><img src="../../../../uploads/LoRaWAN_STM32/STM32_OSC_RTC.png" alt=""></p>
<p>从图中可以看到，IWDG只能使用LSI提供时钟源<br>而RTC可以使用HSE/32(数据手册上查看得来，软件存在明显错误)、LSE、LSI提供时钟源,其中LSE 的频率为32.768KHz，LSI的频率为37KHz。</p>
<p>具体的RTC和IWDG的工作时钟还要进行分频。<br>RTC的工作时钟的计算方法为：Fck_spre = Frtcclk/(PREDIV_S+1)/(PREDIV_A+1);</p>
<p>例如Frtcclk(时钟源频率)为32.768Khz的LSE，PREDIV_S = 3， PREDIV_A =3,则Fck_spre(工作频率) = 32.768/(3+1)/(3+1) = 2.048KHz<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RtcInit</span><span class="params">( <span class="keyword">void</span> )</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	RtcHandle.Init.AsynchPrediv = <span class="number">3</span>;</div><div class="line">    RtcHandle.Init.SynchPrediv = <span class="number">3</span>;	</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line"> * RTC Time base in ms</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_DURATION                     0.48828125      <span class="comment">// 1 tick every 488us</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_PER_MS                       2.048           <span class="comment">// 1/2.048 = tick duration in ms</span></span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN源码阅读笔记————RTC闹钟链表的实现]]></title>
      <url>http://yoursite.com/2016/10/10/semtech_LoRaWAN_timer/</url>
      <content type="html"><![CDATA[<p>近日在阅读semtech的<a href="https://github.com/Lora-net/LoRaMac-node" target="_blank" rel="external">Lora-net/LoRaMac-node</a>。此代码是LoRaWAN MAC层的node段的代码。</p>
<p>此代码中构建了一个定时器链表，此链表构建得非常的巧妙。<br>通过对源码的阅读，明白了其底层的实现原理，现在讲解一下，和大家分享。</p>
<p>此定时器链表底层使用的是RTC的闹钟(Alarm)机制(将日历时间转换成时间戳时间)，而非使用一个定时器产生一个固定的定时(比如1ms)，然后定时刷新整个链表。</p>
<p>用rtc的方法相比较嘀嗒定时器定时的方法，工作效率会明显提升，并不会因为链表中定时器数目的增加使得花费在刷新定时器上的时间增加，因为不需要遍历整个链表。但代码的实现难度会较高</p>
<p>假如程序刚开始执行，而且定时器链表为空，此时有４个定时事件需要放入链表，分别为　A 10ms B 30ms C 20ms D 40ms，</p>
<p>RTC闹钟链表：<br>其存储的结果会是这样:</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>C</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>10</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>而嘀嗒定时链表：<br>其存储的结果会是这样:</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>30</td>
</tr>
<tr>
<td>C</td>
<td>20</td>
</tr>
<tr>
<td>D</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>当时间过了5ms，RTC闹钟链表中存储的数据并不会发生任何变化，因为它是以RTC的闹钟来作为刷新依据的，而嘀嗒定时链表中的数据就全发生了变化<br>嘀嗒定时链表 变化得到情况如下：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>B</td>
<td>25</td>
</tr>
<tr>
<td>C</td>
<td>15</td>
</tr>
<tr>
<td>D</td>
<td>35</td>
</tr>
</tbody>
</table>
<p>再过5ms，此时A事件的定时时间就到了，需要被执行，在RTC闹钟链表中的表现是RTC Alarm中断触发，在嘀嗒定时链表中的表现是A事件的定时时间逐渐减少至0。当A事件被执行之后两种定时器链表中的存储都发生了变化，都是原先的链表的头指针指向原先的第二个节点，而原先的头节点被释放。</p>
<p>还是上述的例子，在定时器执行了7ms的时候，这时有个事件需要插入，为E 24ms，此时，两种链表对于此事件器的插入操作也会明显不同。</p>
<p>RTC闹钟插入之后</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>C</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>10</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
</tr>
<tr>
<td>D</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>而嘀嗒定时器在插入之后为</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>定时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>3</td>
</tr>
<tr>
<td>B</td>
<td>13</td>
</tr>
<tr>
<td>C</td>
<td>23</td>
</tr>
<tr>
<td>D</td>
<td>33</td>
</tr>
<tr>
<td>E</td>
<td>24</td>
</tr>
</tbody>
</table>
<p>以下是RTC闹钟的部分插入代码，其中可以看到他的定时器插入的逻辑<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">elapsedTime = TimerGetValue( );<span class="comment">//获取距离上一次设置闹钟的时间</span></div><div class="line">remainingTime = TimerListHead-&gt;Timestamp - elapsedTime;<span class="comment">//remainingTime表示剩余的头节点中的事件剩余的定时事件，因为此链表是按顺序存储的，所以头节点中的定时时间一定是最少的</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TimerInsertNewHeadTimer</span><span class="params">( TimerEvent_t *obj, <span class="keyword">uint32_t</span> remainingTime )</span></span></div><div class="line">&#123;</div><div class="line">    TimerEvent_t* cur = TimerListHead;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( cur != <span class="literal">NULL</span> )<span class="comment">//表头不为空，将新的定时器插入之前，将原先表头的定时器时间减去新定时器的定时时间，确保原先的定时器任务定时正常</span></div><div class="line">    &#123;</div><div class="line">        cur-&gt;Timestamp = remainingTime - obj-&gt;Timestamp;</div><div class="line">        cur-&gt;IsRunning = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    obj-&gt;Next = cur;</div><div class="line">    obj-&gt;IsRunning = <span class="literal">true</span>;</div><div class="line">    TimerListHead = obj;</div><div class="line">    TimerSetTimeout( TimerListHead );<span class="comment">//设置超时，等时间到的时候，会发生RTC报警</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外还有一点，此RTC中的1s并非物理时间的1s，在此具体的时间基准如下:<br>    此项目中，使用的RTC的时钟源为32.768Khz的LSE，通过AsynchPrediv和SynchPrediv分频得到2.048KHz的RTCtick，计算公式为32.768/(3+1)/(3+1) = 2.048;<br>相关的配置代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RtcInit</span><span class="params">( <span class="keyword">void</span> )</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	RtcHandle.Init.AsynchPrediv = <span class="number">3</span>;</div><div class="line">    RtcHandle.Init.SynchPrediv = <span class="number">3</span>;	</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line"> * RTC Time base in ms</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_DURATION                     0.48828125      <span class="comment">// 1 tick every 488us</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTC_ALARM_TICK_PER_MS                       2.048           <span class="comment">// 1/2.048 = tick duration in ms</span></span></div></pre></td></tr></table></figure></p>
<p>由于原本每个tick相当于1s，而在这里，每个tick相当于0.48828125ms，小于1ms，所以在程序中能够实现ms级的定时任务。</p>
<p>RTC定时器的用法主要分为三步：</p>
<pre><code>1. 初始化，注册回调函数
    void TimerInit( TimerEvent_t *obj, void ( *callback )( void ) )//设置回调函数
2. 设置定时时间
    void TimerSetValue( TimerEvent_t *obj, uint32_t value )
3. 开启定时时间
    void TimerStart( TimerEvent_t *obj )
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN架构解析(二)--LoRaWAN MAC解析]]></title>
      <url>http://yoursite.com/2016/07/29/LoRaWAN_MAC%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><p>上行：终端的数据发送经过一个或多个网关中转到达网络服务器。<br>下行：由网络服务器发送给终端设备，每条消息对应的终端设备是唯一确定的，而且只通过一个网关中转。</p>
<h2 id="LoRaWAN-Classes"><a href="#LoRaWAN-Classes" class="headerlink" title="LoRaWAN Classes"></a>LoRaWAN Classes</h2><p>LoRaWAN Classes 一共分为3类：Class A,Class B,Class C</p>
<p>Class A:终端先发送，在发送后开启一段时间的接收窗口，终端只有在发送后才可以接收。也就是说上行没有限制，下行的数据只有在上行包发送上来的时候终端才可以接收到。(功耗最低)</p>
<p>Class B:终端和服务器协商好接收的窗口开启的时间以及何时开启，然后再约定的时间进行接收，可以一次接收多个包。（功耗次低）</p>
<p>Class C:终端在发送以外的其他时间都开启接收窗口。更耗能，但通讯延时最低。（功耗最高）</p>
<h2 id="PHY-层数据链路"><a href="#PHY-层数据链路" class="headerlink" title="PHY 层数据链路"></a>PHY 层数据链路</h2><p>上行链路消息：<br><img src="../../../../uploads/LoRa/uplink.png" alt=""></p>
<p>上行链路消息：<br><img src="../../../../uploads/LoRa/downlink.png" alt=""></p>
<p>其中上行最后还有CRC校验，而下行没有CRC校验。其中PHDR PHDR_CRC CRC都是射频芯片用于校准数据的完整新和一致性用的，并非用户生成的数据。</p>
<h2 id="MAC-层数据链路"><a href="#MAC-层数据链路" class="headerlink" title="MAC 层数据链路"></a>MAC 层数据链路</h2><p><img src="../../../../uploads/LoRa/PHY_data_format.png" alt=""></p>
<p>由上图可以看到，MAC数据是是作为PHYPayload存在的<br>其中MAC 层的包有三个部分组成：</p>
<ul>
<li>MHDR(MAC层帧头) </li>
<li>MACPayload(MAC层负载) </li>
<li>MIC(4字节的校验)</li>
</ul>
<p>而MACPayload又由三个部分组成:</p>
<ul>
<li>FHDR (MAC层负载头)</li>
<li>FPORT（MAC 层数据的通道号）</li>
<li>FRMPayload（MAC层负载，加密）</li>
</ul>
<p>而FHDR又由由四个部分组成:</p>
<ul>
<li>DevAddr(终端的ID 4字节)</li>
<li>FCtrl（帧的控制字 1个字节）</li>
<li>FCnt （帧的序号 2个字节）</li>
<li>FOpts（帧配置，字节数不定，大部分情况0个字节）</li>
</ul>
<p>所以，由协议可知，一个上行包或者下行包中的数据内容有哪些，抛开控制命令不说，主要有终端的ID、包的序号、用户的加密负载。</p>
<p>例如我抓到的一个数据包：</p>
<p>\x40 \x7f \xf8 \x8a \x29 \x80 \x2a \x00 \x02 \x07 \x42 \x87 \x3f \xc7 \xb4 \x22 \x04 \x00 \x84 \x8d \x1b \x06 \x2f \x5b \xbc \x57 \xdb \xf2 \x31 \xde \x49 \x61 \x00 \x86 \x99 \xec \x08 \x61 \xf0 \xb7 \xda \x54 \x0a \xfa \xd1 \x31 \xac \xd0 \x44 \x1b \x4d \xfa \x48 \x77 \x19 \xee \x61 \x14 \xbf \x23 \x52 \xd1 \xe9 \x93 \x79 \x6e \x16 \xd7 \x13 \x2e \x58 \x06 \x54 \xc3 \xd2 \x04 \xba \x52 \xa7 \xc8 \x7a \x0b \x8e </p>
<p>这是一个MAC 层的帧即完整的MACPayload部分</p>
<p>其中 </p>
<ul>
<li>MHDR:<br>  \x40</li>
<li>MACPayload-FHDR-DevAddr:<br>  \x7f \xf8 \x8a \x29 </li>
<li>MACPayload-FHDR-FCtrl:<br>  \x80 </li>
<li>MACPayload-FHDR-FCnt:<br>  \x2a \x00 </li>
<li>MACPayload-FPORT:<br>  \x02 </li>
<li>MACPayload-FRMPayload（加密）:<br>  \x07 \x42 \x87 \x3f \xc7 \xb4 \x22 \x04 \x00 \x84 \x8d \x1b \x06 \x2f \x5b \xbc \x57 \xdb \xf2 \x31 \xde \x49 \x61 \x00 \x86 \x99 \xec \x08 \x61 \xf0 \xb7 \xda \x54 \x0a \xfa \xd1 \x31 \xac \xd0 \x44 \x1b \x4d \xfa \x48 \x77 \x19 \xee \x61 \x14 \xbf \x23 \x52 \xd1 \xe9 \x93 \x79 \x6e \x16 \xd7 \x13 \x2e \x58 \x06 \x54 \xc3 \xd2 \x04 \xba \x52 \xa7 </li>
<li>MIC:<br>  \xc8 \x7a \x0b \x8e </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MPU9250调试]]></title>
      <url>http://yoursite.com/2016/07/26/MPU9250%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="MPU9250-芯片概述"><a href="#MPU9250-芯片概述" class="headerlink" title="MPU9250 芯片概述"></a>MPU9250 芯片概述</h2><p>MPU9250芯片是一个9轴姿态传感芯片，其中包含了3轴加速度传感器、3轴角速度传感器以及三轴磁力计。<br>其本质上是MPU6050芯片+AK8963。</p>
<p>可以获取传感芯片的加速度、角速度、以及磁力值。</p>
<p>角速度可以知芯片的转动速度，加速度可以知道芯片运动的距离、速度情况，而磁力计可以知道物芯片的运动方向。</p>
<p>另外MPU9250芯片内置DMP姿态融合器，可以在不涉及算法的情况下，直接读取出描述物体状态的四元数，从而得出物体的三维角度–航向角、翻滚角、俯仰角。</p>
<h2 id="驱动程序的设计"><a href="#驱动程序的设计" class="headerlink" title="驱动程序的设计"></a>驱动程序的设计</h2><p>由于MPU9250芯片使用的是I2C接口，所以在这里，我首先需要I2C的驱动。</p>
<p>在我的驱动中，I2C使用GPIO口模拟的，因为这样在以后移植时更加方便。</p>
<p>在完成IOI2C的驱动之后，就是对MPU9250的寄存器进行操作，来成功获取传感数据。</p>
<h2 id="MPU9250的寄存器操作"><a href="#MPU9250的寄存器操作" class="headerlink" title="MPU9250的寄存器操作"></a>MPU9250的寄存器操作</h2><p>操作MPU9250寄存器并且开启DMP模式，获取三维角度，其步骤如下：</p>
<ol>
<li>配置PWR_MGMT_1(一般为00，表示使用内部晶振20Mhz)</li>
<li>设置采样频率</li>
<li>设置量程（角速度、加速度量程）</li>
<li>外部中断打开，并且配置成相应的工作方式</li>
<li>开启DMP，以及FIFO</li>
</ol>
<p>其中DMP的开启需要密码，而且具体的操作方法及寄存器在数据手册上都无法找到，是本人在网站经过查找融合了多人的驱动调试出来的。</p>
<h2 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h2><p>本人将调通之后的代码整理之后，只需调用几个API就可以实现参数的获取了。</p>
<p>主要分为两步：</p>
<ol>
<li>初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IIC_Init();<span class="comment">//模拟I2C驱动的初始化，一定要先初始化I2C接口才能操作MPU9250芯片</span></div><div class="line"></div><div class="line">Init_MPU9250_With_DMP();<span class="comment">//初始化MPU9250,配置并且开启DMP，设置中断方式为加速度方式</span></div></pre></td></tr></table></figure>
<ol>
<li>函数调用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;		</div><div class="line">	fifo_count = MPU9250_getFIFOCount();<span class="comment">//读取FIFO计数</span></div><div class="line">	</div><div class="line">	<span class="keyword">if</span>(fifo_count &gt;= <span class="number">0x0200</span>)<span class="comment">//如果FIFO值&gt;0x0200，此时DMP的结果错误，直接复位FIFO</span></div><div class="line">	&#123;</div><div class="line">		MPU9250_resetFIFO();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(fifo_count &gt;= <span class="number">0x2a</span>)<span class="comment">//如果FIFO值 &gt; 0x2a,此时DMP转换完成并且数值正常</span></div><div class="line">		&#123;				</div><div class="line">			readdmp(); <span class="comment">//首先要读取DMP FIFO，读取之后才能进行计算姿态的操作</span></div><div class="line">			MPU9250_resetFIFO();					</div><div class="line">			getyawpitchroll();<span class="comment">//计算并且获取yaw、pitch、roll，结果保存在yprf[3]数组中</span></div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NOTE:</p>
<ul>
<li><p>在判断DMP是否完成时，应当从FIFO的计数中去判断，当计数大于等于42，说明DMP转换完成，也可以采用中断的方式来作为标志。</p>
</li>
<li><p>本例程中使用的I2C为GPIO模拟的I2C，主要是移植方便，但是在将此驱动移植到不同平台时需要注意寄存器以及引脚的定义。</p>
</li>
</ul>
<p>具体的程序在我的代码库中，欢迎大家能找出其中的不足，E-mail给我。</p>
<p>代码链接如下：<br><a href="https://github.com/AnswerInTheWind/Peripheral/tree/master/MPU9250-MPU6050" target="_blank" rel="external">MPU9250-MPU6050驱动</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LoRaWAN解析(一)--架构解析]]></title>
      <url>http://yoursite.com/2016/07/24/LoRaWan%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="LoRaWAN-分层"><a href="#LoRaWAN-分层" class="headerlink" title="LoRaWAN 分层"></a>LoRaWAN 分层</h2><p>LoRaWAN从底层到最后用户拿到数据的通讯过程通讯大致可分为三段：</p>
<ol>
<li>MOTE &lt;—&gt; GW (MAC层)</li>
<li>GW &lt;—&gt; NS</li>
<li>NS &lt;—&gt; Customer</li>
</ol>
<p>LoRa联盟 规定了 MAC层的通讯协议，只有在设备（GW、MOTE）共同遵守的MAC层协议的前提下，不同硬件厂商的设备才能互相接入。</p>
<p>而GW &lt;—&gt; NS以及NS &lt;—&gt; Customer这两层的协议虽然LoRa联盟有所规范，但不同厂商之间可能会存在不同。</p>
<h2 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h2><p>在这里我以LoRaWAN 方式实现农场的土壤湿度检测来做说明。<br>实现农场的土壤湿度的检测主要分为几个步骤：</p>
<ul>
<li>实现传感器采集土壤湿度（sensor层）</li>
<li>将采集到的土壤湿度通过MOTE发送给GW(LoRaMac 层)</li>
<li>GW将收到的数据发送给NS（GW&lt;—&gt;NS）</li>
<li>NS再将数据发送给用户(NS&lt;—&gt;Customer)</li>
<li>用户通过APP或者其他方式可以看到土壤的湿度状态。(Display)</li>
</ul>
<p>通过以上的几个步骤，就可以实现远程监控农场土壤湿度。</p>
<p>好了，第一讲非常的简单。只是讲解了LoRaWAN 作为IOT的一种方式，其中的数据流向。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[74HC165的级联以及MCU硬件SPI的通讯]]></title>
      <url>http://yoursite.com/2016/07/21/74HC165/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>74HC165作为常用的IO口扩展芯片，常用于并行IO口状态转串行数据。一块74HC165芯片可以连接8个IO口，将8个IO口状态转换成8位串行的数据传输给MCU。也就是说可以通过两个IO口获取到8个IO口的状态。<br>在电路设计中，也经常将74HC165芯片级联使用。通过芯片的级联，可以达到2个IO口读取16个IO口状态（2片级联）的效果，甚至更多。</p>
<p>由于74HC165的操作时序刚SPI的时序恰好相同，所以可以通过MCU的硬件SPI接口来操作74HC165芯片，这种通过MCU硬件接口来操作芯片的优点如下：</p>
<ul>
<li>硬件的SPI时钟速度高，STM32芯片舌诊可以达到20MHZ，这样获取IO口状态的速度快，实时性更强</li>
<li>扫描周期更短，可以使用在一些判断IO口状态的应用中，如扫描是否有物体高速穿过</li>
</ul>
<h2 id="软件的实现思路"><a href="#软件的实现思路" class="headerlink" title="软件的实现思路"></a>软件的实现思路</h2><p>由于使用的是MCU的硬件SPI接口，所以程序和MCU的型号会有较大关系，在这里，我以STM32F103RCT6为例。</p>
<p>步骤如下:</p>
<ol>
<li>将MCU的SPI复用IO口初始化</li>
<li><p>配置SPI寄存器,示例代码如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SPI_I2S_DeInit(SPI1);</div><div class="line">SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;<span class="comment">// Receive-only mode</span></div><div class="line">SPI_InitStructure.SPI_Mode=SPI_Mode_Master;<span class="comment">// </span></div><div class="line">SPI_InitStructure.SPI_DataSize=SPI_DataSize_16b;<span class="comment">// Data word = 16 bit wide</span></div><div class="line">SPI_InitStructure.SPI_CPOL=SPI_CPOL_High;<span class="comment">// Clock default level = L</span></div><div class="line">SPI_InitStructure.SPI_CPHA=SPI_CPHA_1Edge;<span class="comment">// Latch on the first edge (rising from L)</span></div><div class="line">SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;<span class="comment">// Software controls select SS signal, SS pin is GPIO</span></div><div class="line">SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_4; <span class="comment">// SPI_BaudRatePrescaler_4</span></div><div class="line">SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_LSB;<span class="comment">// MSB first</span></div><div class="line">SPI_InitStructure.SPI_CRCPolynomial=<span class="number">7</span>;<span class="comment">// No CRC required</span></div><div class="line">SPI_Init(SPI1, &amp;SPI_InitStructure);</div></pre></td></tr></table></figure>
<p> 其中需要注意的是分频的值和数据位长度，由于这边是2片级联，所以使用的是16b</p>
</li>
<li><p>SPI读取，代码如下： </p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GPIOC-&gt;BSRR = GPIO_Pin_5;<span class="comment">//片选选中</span></div><div class="line"></div><div class="line"><span class="keyword">while</span>((SPI1-&gt;SR &amp; SPI_I2S_FLAG_TXE) == <span class="number">0</span>);<span class="comment">//判断数据发送完成</span></div><div class="line">SPI1-&gt;DR = <span class="number">0xFFFF</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span>((SPI1-&gt;SR &amp; SPI_I2S_FLAG_RXNE) == <span class="number">0</span>);<span class="comment">//判断数据接受完成</span></div><div class="line">temp1 = SPI1-&gt;DR;</div><div class="line"></div><div class="line">GPIOC-&gt;BRR = GPIO_Pin_5;<span class="comment">//片选取消选中</span></div></pre></td></tr></table></figure>
<p> 思路就是利用硬件的SPI时序以及SPI每写一位就会返回一位的特性，向74HC165芯片写入16bit的数据,便会在SPI寄存器中获取到两片级联的74HC165的状态。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cJSON_json包的C语言解析库]]></title>
      <url>http://yoursite.com/2016/07/21/CJSON_JSON%E5%8C%85%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="cJSON库描述"><a href="#cJSON库描述" class="headerlink" title="cJSON库描述"></a>cJSON库描述</h2><p>CJSON是一个用于解析JSON包的C语言库，库文件为cJSON.c和cJSON.h，<br>所有的实现都在这两个文件中。原作者的地址<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="external">cJSON</a>。</p>
<h2 id="JSON包的解析"><a href="#JSON包的解析" class="headerlink" title="JSON包的解析"></a>JSON包的解析</h2><p>例如有一个JSON的数据包如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"rxpk"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tmst"</span>: <span class="number">1868500100</span>,</div><div class="line">            <span class="string">"time"</span>: <span class="string">"2016-07-07T13:20:40.003906Z"</span>,</div><div class="line">            <span class="string">"chan"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"rfch"</span>: <span class="number">0</span>,</div><div class="line">            <span class="string">"freq"</span>: <span class="number">779.7</span>,</div><div class="line">            <span class="string">"stat"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"modu"</span>: <span class="string">"LORA"</span>,</div><div class="line">            <span class="string">"datr"</span>: <span class="string">"SF9BW125"</span>,</div><div class="line">            <span class="string">"codr"</span>: <span class="string">"4/5"</span>,</div><div class="line">            <span class="string">"lsnr"</span>: <span class="number">9.8</span>,</div><div class="line">            <span class="string">"rssi"</span>: <span class="number">-37</span>,</div><div class="line">            <span class="string">"size"</span>: <span class="number">83</span>,</div><div class="line">            <span class="string">"data"</span>: <span class="string">"QH/4iimAKgACB0KHP8e0IgQAhI0bBi9bvFfb8jHeSWEAhpnsCGHwt9pUCvrRMazQRBtN+kh3Ge5hFL8jUtHpk3luFtcTLlgGVMPSBLpSp8h6C44="</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要获取其中的data字段，需要进行的过程如下：</p>
<ol>
<li><p>首先声明变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cJSON *json;</div><div class="line">cJSON *rxpk;		</div><div class="line">cJSON *arr0;</div><div class="line">cJSON *data;</div></pre></td></tr></table></figure>
</li>
<li><p>将上述的字符串进行解析,并保存在json中;</p>
</li>
<li>获取json其中的rxpk字段的内容，并保存在rxpk中;</li>
<li>获取rxpk中的arr部分，拿出一种的第一个数组，并保存在arr0;</li>
<li>获取arr0的data部分，并保存在data;</li>
<li>使用data-&gt;valuestring即可获取其中的data字段的内容<br>具体的代码实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint16_t</span> rxpk_data_get(<span class="keyword">char</span>* text,<span class="keyword">char</span>* dest_str)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint16_t</span> len = <span class="number">0</span>;</div><div class="line">    cJSON *json;</div><div class="line">    cJSON *data;</div><div class="line">    cJSON *arr0;</div><div class="line">    cJSON *rxpk;</div><div class="line"></div><div class="line">    json= cJSON_Parse(text);</div><div class="line">    <span class="keyword">if</span>(!json)<span class="comment">//对JSON包进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    rxpk = cJSON_GetObjectItem(json,<span class="string">"rxpk"</span>);</div><div class="line">    <span class="keyword">if</span>(!rxpk)<span class="comment">//对rxpk进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    arr0 = cJSON_GetArrayItem(rxpk,<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(!arr0)<span class="comment">//对arr0进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    data =cJSON_GetObjectItem(arr0,<span class="string">"data"</span>);</div><div class="line">    <span class="keyword">if</span>(!data)<span class="comment">//对data进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    len = <span class="built_in">strlen</span>(data-&gt;valuestring);</div><div class="line">    <span class="built_in">memcpy</span>(dest_str,data-&gt;valuestring,len);</div><div class="line">    dest_str[len] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在json包中遇到数组时<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Returns the number of items in an array (or object). */</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span>	  <span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数可以获取数组的长度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[base64的C语言实现]]></title>
      <url>http://yoursite.com/2016/07/21/base64_C/</url>
      <content type="html"><![CDATA[<p>首先谢谢这位大神的<a href="https://github.com/zhicheng" target="_blank" rel="external">github</a>,再谢谢这位大神分享的base64的C语言实现代码，库的地址在这里<a href="https://github.com/zhicheng/base64" target="_blank" rel="external">base64</a>。</p>
<p>其中提供的接口非常的简单明了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_ENCODE_OUT_SIZE(s)	(((s) + 2) / 3 * 4)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_DECODE_OUT_SIZE(s)	(((s)) / 4 * 3)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen,<span class="keyword">char</span> *out)</span></span>;</div></pre></td></tr></table></figure></p>
<p>但是其中有一个问题，base64_decode();函数在返回时并没有返回解码后的字节数，在使用上会存在不方便的情况。</p>
<p>故，我把这个函数稍加修改之后,在解码之后返回解码数组的长度，在使用上就方便很多了，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; inlen; i++) &#123;</div><div class="line">		<span class="keyword">int</span> c;</div><div class="line">		<span class="keyword">int</span> s = i % <span class="number">4</span>; 			<span class="comment">/* from 8/gcd(6, 8) */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] == <span class="string">'='</span>)</div><div class="line">			<span class="keyword">return</span> j;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] &lt; BASE64DE_FIRST || in[i] &gt; BASE64DE_LAST ||</div><div class="line">		    (c = base64de[in[i] - BASE64DE_FIRST]) == <span class="number">-1</span>)</div><div class="line">			<span class="keyword">return</span> j;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (s) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">			out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFF</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x3</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">3</span>) || in[inlen - <span class="number">2</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">4</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">2</span>) || in[inlen - <span class="number">1</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] =  ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">6</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			out[j++] += (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> input[] = <span class="string">"pleasure."</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> decode[<span class="number">13</span>];</div><div class="line">	<span class="keyword">char</span> output[<span class="number">13</span>];</div><div class="line">	<span class="keyword">uint16_t</span> len_decode = <span class="number">0</span>;</div><div class="line">	bzero(output, <span class="keyword">sizeof</span>(output));</div><div class="line">	base64_encode(input, <span class="keyword">sizeof</span>(input) - <span class="number">1</span>, output);</div><div class="line">	len_decode = base64_decode(output, <span class="keyword">sizeof</span>(output) - <span class="number">1</span>, decode);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32L051 PVD的调试]]></title>
      <url>http://yoursite.com/2016/07/11/STM32_PVD/</url>
      <content type="html"><![CDATA[<p>我的PVD的驱动以及例程位于<a href="http://https://github.com/AnswerInTheWind/STM32L0xx_Drivers" title="STM32L0xx_Drivers" target="_blank" rel="external">STM32L0xx_Drivers</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>PVD 是一种检测MCU供电情况的技术。当供电电压高于或者低于一定阈值的时候，可以在寄存器上体现出来，或者直接产生硬件中断。<br>在实际使用MCU时，特别是电池供电的方案中，往往会遇到供电不够导致MCU或者外设工作不正常的情况。PVD在这个时候就可以派上用场了。<br>PVD的使用按照数据手册上的说明，就是首先设置PVD阈值（PVD thresholds），当MCU的VDD引脚的电压高于阈值时，则PVD output=1，当VDD电压低于阈值时，PVD output=0，如下图所示：</p>
<p><img src="../../../../uploads/PVD_images/PVD_1.jpg" alt=""></p>
<p>其中PVD output的结果可以再在存器中查看到 </p>
<p><img src="../../../../uploads/PVD_images/PVD_4.jpg" alt=""><br><img src="../../../../uploads/PVD_images/PVD_3.jpg" alt=""></p>
<p>关于PVD的阈值的设定共有两种方式：</p>
<ul>
<li>固定阈值(1.9V 2.1V 2.3V 2.5V 2.7V 2.9V 3.1V)</li>
<li>与引脚比较（PB7）</li>
</ul>
<p>在实际使用的过程中,PVD可以用查询挥着中断的方式来工作。</p>
<p>在测试的例程中，我配置PVD工作方式为中断上升下降沿触发，当VDD高于预设PVD阈值或者低于阈值而产生边沿触发时，都会形成一次PVD中断，然后读取PWR_CSR的PVDO标志位检查是低电压提醒还是高电压提醒，以此来达到监控MCU供电情况的目的。</p>
<p>注意：当使用PVD功能检测低电压时，VDD电压刚刚小于阈值时并不会直接产生PVD中断，只有当VDD电压小于（阈值-50MV）时，才会产生中断。</p>
<p>如果有什么疑问或者错误欢迎大家指正，email:454626653@qq.com</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以帧为存储单位的循环stack]]></title>
      <url>http://yoursite.com/2016/07/11/%E6%9E%84%E5%BB%BA%E4%BB%A5%E5%B8%A7%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84stack/</url>
      <content type="html"><![CDATA[<p>此stack主要是作为存储空间使用，主要的借口就是push和pop。</p>
<p>stack frame的src以及例程位于<a href="https://github.com/AnswerInTheWind/Data_Structure/tree/master/stack_FrameTest" target="_blank" rel="external">stack_FrameTest</a>这个库当中，其中有readme文件，可以快速上手。</p>
<h2 id="stack构造及代码实现"><a href="#stack构造及代码实现" class="headerlink" title="stack构造及代码实现"></a>stack构造及代码实现</h2><p>其中我对stack以及frame的构造的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Frame</div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint8_t</span> frame_len;<span class="comment">//帧的字节数</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_data[MAX_TRANSMISSION_UINT];<span class="comment">//一帧数据最大为MAX_TRANSMISSION_UINT字节</span></div><div class="line">&#125;Frame;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STACK</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int8_t</span> frame_lastNum;<span class="comment">//最新的帧的序号</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_count;<span class="comment">//stack中未取出的帧的个数</span></div><div class="line">	Frame frame_info[MAX_STACK_FRAME_NUM];<span class="comment">//stack中最多允许存储MAX_STACK_FRAME_NUM个帧</span></div><div class="line">&#125;STACK;</div></pre></td></tr></table></figure></p>
<p>首先构造了一个stack，stack包含两个内容:</p>
<ol>
<li>stack的统计信息：stack中帧的个数(frame_count)，最新的帧的ID(frame_lastNum)；</li>
<li>数据存储区–一个数组，数据格式为Frame，容量为MAX_STACK_FRAME_NUM(frame_info[MAX_STACK_FRAME_NUM])；</li>
</ol>
<p>然后，帧的构造也包含了两个部分：</p>
<ol>
<li>此帧数据的字节数(frame_len)；</li>
<li>数据存储空间–数组,数据格式为uint8_t,容量为MAX_TRANSMISSION_UINT(frame_data[MAX_TRANSMISSION_UINT])；</li>
</ol>
<p>另外，此stack为一个循环栈，当stack存满之后仍有数据存入，并不会发生越界，而是会从头开始覆盖，此种操作，有利也有弊。</p>
<h2 id="拼包机制"><a href="#拼包机制" class="headerlink" title="拼包机制"></a>拼包机制</h2><p>在最后，此例程中还写了一个拼包的机制，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将stack中的数据进行拼包,在不造成断包的情况下最大限度地拼包</span></div><div class="line"><span class="keyword">uint8_t</span> SpliceFrame(<span class="keyword">uint8_t</span>* dest)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">		<span class="comment">//确保当前数据加下一帧数据不会超过最大单帧负载量(MTU)</span></div><div class="line">        <span class="keyword">if</span>((Splice_len +Stack_GetFrameLastNum()) &lt;= MAX_TRANSMISSION_UINT)</div><div class="line">        &#123;</div><div class="line">            Splice_len +=Stack_PopData(dest+Splice_len);<span class="comment">//</span></div><div class="line">            <span class="keyword">if</span>(Stack_GetFrameCount() == <span class="number">0</span>)<span class="comment">//当前融合帧的数量小于stack中已存帧的数量</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Splice_len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>思路就是假如当MTU=70，而如果收到的数据为10bytes，10bytes这样的短数据，我们就可以把这样的短数据由多个包拼接成一个包，一次性发送出去，提高通道的利用效率，因为一次发送70个字节所需的时间大约为5s，而一次发送10个字节的时间也基本等于5s，但是拼包的时候如果造成断包，在接收端处理会非常的麻烦，所以拼包机制制定成这样–在不造成断包以及不超过MTU的情况下最大限度地拼包。</p>
<p>有任何问题欢迎联系我。</p>
]]></content>
    </entry>
    
  
  
</search>
