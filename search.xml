<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[base64的C语言实现]]></title>
      <url>http://yoursite.com/2016/07/21/base64_C/</url>
      <content type="html"><![CDATA[<p>首先谢谢这位大神的<a href="https://github.com/zhicheng" target="_blank" rel="external">github</a>,再谢谢这位大声分享的base64的C语言实现代码，库的地址在这里<a href="https://github.com/zhicheng/base64" target="_blank" rel="external">base</a>。</p>
<p>其中提供的接口非常的简单明了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_ENCODE_OUT_SIZE(s)	(((s) + 2) / 3 * 4)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE64_DECODE_OUT_SIZE(s)	(((s)) / 4 * 3)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen,<span class="keyword">char</span> *out)</span></span>;</div></pre></td></tr></table></figure></p>
<p>但是其中有一个问题，base64_decode();函数在返回时并没有返回解码后的字节数，在使用上会存在不方便的情况。</p>
<p>故，我把这个函数稍加修改之后,在解码之后返回解码数组的长度，在使用上就方便很多了，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen, <span class="keyword">char</span> *out)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; inlen; i++) &#123;</div><div class="line">		<span class="keyword">int</span> c;</div><div class="line">		<span class="keyword">int</span> s = i % <span class="number">4</span>; 			<span class="comment">/* from 8/gcd(6, 8) */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] == <span class="string">'='</span>)</div><div class="line">			<span class="keyword">return</span> len;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (in[i] &lt; BASE64DE_FIRST || in[i] &gt; BASE64DE_LAST ||</div><div class="line">		    (c = base64de[in[i] - BASE64DE_FIRST]) == <span class="number">-1</span>)</div><div class="line">			<span class="keyword">return</span> len;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (s) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">			out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFF</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x3</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">3</span>) || in[inlen - <span class="number">2</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">4</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			out[j++] += ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span>;</div><div class="line">			<span class="comment">/* if not last char with padding */</span></div><div class="line">			<span class="keyword">if</span> (i &lt; (inlen - <span class="number">2</span>) || in[inlen - <span class="number">1</span>] != <span class="string">'='</span>)</div><div class="line">				out[j] =  ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)c &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">6</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			out[j++] += (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> input[] = <span class="string">"pleasure."</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> decode[<span class="number">13</span>];</div><div class="line">	<span class="keyword">char</span> output[<span class="number">13</span>];</div><div class="line">	<span class="keyword">uint16_t</span> len_decode = <span class="number">0</span>;</div><div class="line">	bzero(output, <span class="keyword">sizeof</span>(output));</div><div class="line">	base64_encode(input, <span class="keyword">sizeof</span>(input) - <span class="number">1</span>, output);</div><div class="line">	len_decode = base64_decode(output, <span class="keyword">sizeof</span>(output) - <span class="number">1</span>, decode);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cJSON_json包的C语言解析库]]></title>
      <url>http://yoursite.com/2016/07/21/CJSON_JSON%E5%8C%85%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="cJSON库描述"><a href="#cJSON库描述" class="headerlink" title="cJSON库描述"></a>cJSON库描述</h2><p>CJSON是一个用于解析JSON包的C语言库，库文件为cJSON.c和cJSON.h，<br>所有的实现都在这两个文件中。原作者的地址<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="external">cJSON</a>。</p>
<h2 id="JSON包的解析"><a href="#JSON包的解析" class="headerlink" title="JSON包的解析"></a>JSON包的解析</h2><p>例如有一个JSON的数据包如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"rxpk"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tmst"</span>: <span class="number">1868500100</span>,</div><div class="line">            <span class="string">"time"</span>: <span class="string">"2016-07-07T13:20:40.003906Z"</span>,</div><div class="line">            <span class="string">"chan"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"rfch"</span>: <span class="number">0</span>,</div><div class="line">            <span class="string">"freq"</span>: <span class="number">779.7</span>,</div><div class="line">            <span class="string">"stat"</span>: <span class="number">1</span>,</div><div class="line">            <span class="string">"modu"</span>: <span class="string">"LORA"</span>,</div><div class="line">            <span class="string">"datr"</span>: <span class="string">"SF9BW125"</span>,</div><div class="line">            <span class="string">"codr"</span>: <span class="string">"4/5"</span>,</div><div class="line">            <span class="string">"lsnr"</span>: <span class="number">9.8</span>,</div><div class="line">            <span class="string">"rssi"</span>: <span class="number">-37</span>,</div><div class="line">            <span class="string">"size"</span>: <span class="number">83</span>,</div><div class="line">            <span class="string">"data"</span>: <span class="string">"QH/4iimAKgACB0KHP8e0IgQAhI0bBi9bvFfb8jHeSWEAhpnsCGHwt9pUCvrRMazQRBtN+kh3Ge5hFL8jUtHpk3luFtcTLlgGVMPSBLpSp8h6C44="</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要获取其中的data字段，需要进行的过程如下：</p>
<ol>
<li><p>首先声明变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cJSON *json;</div><div class="line">cJSON *rxpk;		</div><div class="line">cJSON *arr0;</div><div class="line">cJSON *data;</div></pre></td></tr></table></figure>
</li>
<li><p>将上述的字符串进行解析,并保存在json中;</p>
</li>
<li>获取json其中的rxpk字段的内容，并保存在rxpk中;</li>
<li>获取rxpk中的arr部分，拿出一种的第一个数组，并保存在arr0;</li>
<li>获取arr0的data部分，并保存在data;</li>
<li>使用data-&gt;valuestring即可获取其中的data字段的内容<br>具体的代码实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint16_t</span> rxpk_data_get(<span class="keyword">char</span>* text,<span class="keyword">char</span>* dest_str)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint16_t</span> len = <span class="number">0</span>;</div><div class="line">    cJSON *json;</div><div class="line">    cJSON *data;</div><div class="line">    cJSON *arr0;</div><div class="line">    cJSON *rxpk;</div><div class="line"></div><div class="line">    json= cJSON_Parse(text);</div><div class="line">    <span class="keyword">if</span>(!json)<span class="comment">//对JSON包进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    rxpk = cJSON_GetObjectItem(json,<span class="string">"rxpk"</span>);</div><div class="line">    <span class="keyword">if</span>(!rxpk)<span class="comment">//对rxpk进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    arr0 = cJSON_GetArrayItem(rxpk,<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(!arr0)<span class="comment">//对arr0进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    data =cJSON_GetObjectItem(arr0,<span class="string">"data"</span>);</div><div class="line">    <span class="keyword">if</span>(!data)<span class="comment">//对data进行合法性检查</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    len = <span class="built_in">strlen</span>(data-&gt;valuestring);</div><div class="line">    <span class="built_in">memcpy</span>(dest_str,data-&gt;valuestring,len);</div><div class="line">    dest_str[len] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在json包中遇到数组时<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Returns the number of items in an array (or object). */</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span>	  <span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数可以获取数组的长度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以帧为存储单位的循环stack存储结构的设计]]></title>
      <url>http://yoursite.com/2016/07/11/%E6%9E%84%E5%BB%BA%E4%BB%A5%E5%B8%A7%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84stack/</url>
      <content type="html"><![CDATA[<p>我的stack frame的src以及例程位于<a href="https://github.com/AnswerInTheWind/Data_Structure/tree/master/stack_FrameTest" target="_blank" rel="external">stack_FrameTest</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>为了配合项目的需要，我构造了一个循环的stack，stack是一种后进先出的存储结构，在实际中使用这种存储结构，可以使保证最新的数据拥有最高优先级。<br>在物联网的系统中，往往需要获取传感器的最新的状态，所以传输传感器的最新状态往往比传送之前的状态更有意义。</p>
<h2 id="stack构造及代码实现"><a href="#stack构造及代码实现" class="headerlink" title="stack构造及代码实现"></a>stack构造及代码实现</h2><p>其中我对stack以及frame的构造的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Frame</div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint8_t</span> frame_len;<span class="comment">//帧的字节数</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_data[MAX_TRANSMISSION_UINT];<span class="comment">//帧的存储空间</span></div><div class="line">&#125;Frame;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STACK</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int8_t</span> frame_lastNum;<span class="comment">//最近的帧的序号</span></div><div class="line">	<span class="keyword">uint8_t</span> frame_count;<span class="comment">//stack中的帧的个数</span></div><div class="line">	Frame frame_info[MAX_STACK_FRAME_NUM];<span class="comment">//最多允许存储MAX_STACK_FRAME_NUM帧</span></div><div class="line">&#125;STACK;</div></pre></td></tr></table></figure></p>
<p>首先构造了一个stack，stack包含两个内容:</p>
<ol>
<li>stack的统计信息：stack中帧的个数，最新的帧的ID；</li>
<li>数据存储区,所有帧的数据存放区域；</li>
</ol>
<p>然后，帧的构造也包含了两个部分：</p>
<ol>
<li>此frame中的数据存储区中的有效数据的字节数；</li>
<li>数据存储区，此帧的数据存放区域；</li>
</ol>
<p>循环意味着此stack并非标准的stack，没有栈顶限制，当栈满了，仍然有数据进入时，数据从帧底开始存储，相当于栈底的原来的数据会被覆盖掉，也就没了栈越界的危险。</p>
<h2 id="此数据结构的优点"><a href="#此数据结构的优点" class="headerlink" title="此数据结构的优点"></a>此数据结构的优点</h2><ol>
<li>永远是最新的数据被最优先处理；</li>
<li>没有栈越界的危险，在嵌入式或者其他队稳定性要求较高的环境中，可靠，不会因为数据过多出现指针异常导致崩溃的情况出现；</li>
<li>在海量数据涌来但无法全部进行处理的时候，选择最新的数据保存，进行处理，保证了数据的实时性；</li>
</ol>
<h2 id="此数据结构也有明显的缺点"><a href="#此数据结构也有明显的缺点" class="headerlink" title="此数据结构也有明显的缺点"></a>此数据结构也有明显的缺点</h2><ol>
<li>如果处理速度慢，较早的未处理的数据被覆盖就再也无法找回了；</li>
<li>由于stack中frame的存储空间是静态分配的，而不是在运行时动态分配的，若frame的负载情况远远小于MTU，则会出现大量空间被浪费的情况；</li>
</ol>
<h2 id="拼包机制"><a href="#拼包机制" class="headerlink" title="拼包机制"></a>拼包机制</h2><p>在最后，此例程中还写了一个拼包的机制，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将stack中的数据进行拼包,在不造成断包的情况下最大限度地拼包</span></div><div class="line"><span class="keyword">uint8_t</span> SpliceFrame(<span class="keyword">uint8_t</span>* dest)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    Splice_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">		<span class="comment">//确保当前数据加下一帧数据不会超过最大单帧负载量(MTU)</span></div><div class="line">        <span class="keyword">if</span>((Splice_len +Stack_GetFrameLastNum()) &lt;= MAX_TRANSMISSION_UINT)</div><div class="line">        &#123;</div><div class="line">            Splice_len +=Stack_PopData(dest+Splice_len);<span class="comment">//</span></div><div class="line">            <span class="keyword">if</span>(Stack_GetFrameCount() == <span class="number">0</span>)<span class="comment">//当前融合帧的数量小于stack中已存帧的数量</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Splice_len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从程序中可见，此拼包的机制就是在MTU的限制内，在不造成断包的情况下，最大限度的地将stack中已经已有的数据包进行拼包，打包成一个较长的数据包进行处理。此拼包机制在无线网络中可以大大提高无线信道的传输效率。具体的测试情况可以查看源代码。</p>
<p>如果有什么疑问或者错误欢迎大家指正，欢迎大家评论或者提出issues.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32L051 PVD的调试]]></title>
      <url>http://yoursite.com/2016/07/11/STM32_PVD/</url>
      <content type="html"><![CDATA[<p>我的PVD的驱动以及例程位于<a href="http://https://github.com/AnswerInTheWind/STM32L0xx_Drivers" title="STM32L0xx_Drivers" target="_blank" rel="external">STM32L0xx_Drivers</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>PVD 是一种检测MCU供电情况的技术。当供电电压高于或者低于一定阈值的时候，可以在寄存器上体现出来，或者直接产生硬件中断。<br>在实际使用MCU时，特别是电池供电的方案中，往往会遇到供电不够导致MCU或者外设工作不正常的情况。PVD在这个时候就可以派上用场了。<br>PVD的使用按照数据手册上的说明，就是首先设置PVD阈值（PVD thresholds），当MCU的VDD引脚的电压高于阈值时，则PVD output=1，当VDD电压低于阈值时，PVD output=0，如下图所示：</p>
<p><img src="../../../../uploads/PVD_images/PVD_1.jpg" alt=""></p>
<p>其中PVD output的结果可以再在存器中查看到 </p>
<p><img src="../../../../uploads/PVD_images/PVD_4.jpg" alt=""><br><img src="../../../../uploads/PVD_images/PVD_3.jpg" alt=""></p>
<p>关于PVD的阈值的设定共有两种方式：</p>
<ul>
<li>固定阈值(1.9V 2.1V 2.3V 2.5V 2.7V 2.9V 3.1V)</li>
<li>与引脚比较（PB7）</li>
</ul>
<p>在实际使用的过程中,PVD可以用查询挥着中断的方式来工作。</p>
<p>在测试的例程中，我配置PVD工作方式为中断上升下降沿触发，当VDD高于预设PVD阈值或者低于阈值而产生边沿触发时，都会形成一次PVD中断，然后读取PWR_CSR的PVDO标志位检查是低电压提醒还是高电压提醒，以此来达到监控MCU供电情况的目的。</p>
<p>注意：当使用PVD功能检测低电压时，VDD电压刚刚小于阈值时并不会直接产生PVD中断，只有当VDD电压小于（阈值-50MV）时，才会产生中断。</p>
<p>如果有什么疑问或者错误欢迎大家指正，email:454626653@qq.com</p>
]]></content>
    </entry>
    
  
  
</search>
