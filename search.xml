<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[以帧为存储单位的循环stack存储结构的设计]]></title>
      <url>http://yoursite.com/2016/07/11/%E6%9E%84%E5%BB%BA%E4%BB%A5%E5%B8%A7%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84stack/</url>
      <content type="html"><![CDATA[<p>我的stack frame的src以及例程位于<a href="https://github.com/AnswerInTheWind/Data_Structure/tree/master/stack_FrameTest" target="_blank" rel="external">stack_FrameTest</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>为了配合项目的需要，我构造了一个循环的stack，stack是一种后进先出的存储结构，在实际中使用这种存储结构，可以使保证最新的数据拥有最高优先级。<br>在物联网的系统中，往往需要获取传感器的最新的状态，所以传输传感器的最新状态往往比传送之前的状态更有意义。</p>
<h2 id="stack构造及代码实现"><a href="#stack构造及代码实现" class="headerlink" title="stack构造及代码实现"></a>stack构造及代码实现</h2><p>其中我对stack以及frame的构造的代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct Frame</div><div class="line">&#123;</div><div class="line">	uint8_t frame_len;//帧的字节数</div><div class="line">	uint8_t frame_data[MAX_TRANSMISSION_UINT];//帧的存储空间</div><div class="line">&#125;Frame;</div><div class="line"></div><div class="line">typedef struct STACK</div><div class="line">&#123;</div><div class="line">	int8_t frame_lastNum;//最近的帧的序号</div><div class="line">	uint8_t frame_count;//stack中的帧的个数</div><div class="line">	Frame frame_info[MAX_STACK_FRAME_NUM];//最多允许存储MAX_STACK_FRAME_NUM帧</div><div class="line">&#125;STACK;</div></pre></td></tr></table></figure></p>
<p>首先构造了一个stack，stack包含两个内容:</p>
<ol>
<li>stack的统计信息：stack中帧的个数，最新的帧的ID；</li>
<li>数据存储区,所有帧的数据存放区域；</li>
</ol>
<p>然后，帧的构造也包含了两个部分：</p>
<ol>
<li>此frame中的数据存储区中的有效数据的字节数；</li>
<li>数据存储区，此帧的数据存放区域；</li>
</ol>
<p>循环意味着此stack并非标准的stack，没有栈顶限制，当栈满了，仍然有数据进入时，数据从帧底开始存储，相当于栈底的原来的数据会被覆盖掉，也就没了栈越界的危险。</p>
<h2 id="此数据结构的优点"><a href="#此数据结构的优点" class="headerlink" title="此数据结构的优点"></a>此数据结构的优点</h2><ol>
<li>永远是最新的数据被最优先处理；</li>
<li>没有栈越界的危险，在嵌入式或者其他队稳定性要求较高的环境中，可靠，不会因为数据过多出现指针异常导致崩溃的情况出现；</li>
<li>在海量数据涌来但无法全部进行处理的时候，选择最新的数据保存，进行处理，保证了数据的实时性；</li>
</ol>
<h2 id="此数据结构也有明显的缺点"><a href="#此数据结构也有明显的缺点" class="headerlink" title="此数据结构也有明显的缺点"></a>此数据结构也有明显的缺点</h2><ol>
<li>如果处理速度慢，较早的未处理的数据被覆盖就再也无法找回了；</li>
<li>由于stack中frame的存储空间是静态分配的，而不是在运行时动态分配的，若frame的负载情况远远小于MTU，则会出现大量空间被浪费的情况；</li>
</ol>
<h2 id="拼包机制"><a href="#拼包机制" class="headerlink" title="拼包机制"></a>拼包机制</h2><p>在最后，此例程中还写了一个拼包的机制，代码如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//将stack中的数据进行拼包,在不造成断包的情况下最大限度地拼包</div><div class="line">uint8_t SpliceFrame(uint8_t* dest)</div><div class="line">&#123;</div><div class="line">    uint8_t Splice_len = 0;</div><div class="line"></div><div class="line">    Splice_len = 0;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(1)</div><div class="line">    &#123;</div><div class="line">		//确保当前数据加下一帧数据不会超过最大单帧负载量(MTU)</div><div class="line">        <span class="keyword">if</span>((Splice_len +Stack_GetFrameLastNum()) &lt;= MAX_TRANSMISSION_UINT)</div><div class="line">        &#123;</div><div class="line">            Splice_len +=Stack_PopData(dest+Splice_len);//</div><div class="line">            <span class="keyword">if</span>(Stack_GetFrameCount() == 0)//当前融合帧的数量小于stack中已存帧的数量</div><div class="line">               <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> Splice_len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从程序中可见，此拼包的机制就是在MTU的限制内，在不造成断包的情况下，最大限度的地将stack中已经已有的数据包进行拼包，打包成一个较长的数据包进行处理。此拼包机制在无线网络中可以大大提高无线信道的传输效率。具体的测试情况可以查看源代码。</p>
<p>如果有什么疑问或者错误欢迎大家指正，欢迎大家评论或者提出issues.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STM32L051 PVD的调试]]></title>
      <url>http://yoursite.com/2016/07/11/STM32_PVD/</url>
      <content type="html"><![CDATA[<p>我的PVD的驱动以及例程位于<a href="http://https://github.com/AnswerInTheWind/STM32L0xx_Drivers" title="STM32L0xx_Drivers" target="_blank" rel="external">STM32L0xx_Drivers</a>这个库当中，在使用前最好先阅读readme.md文件</p>
<p>PVD 是一种检测MCU供电情况的技术。当供电电压高于或者低于一定阈值的时候，可以在寄存器上体现出来，或者直接产生硬件中断。<br>在实际使用MCU时，特别是电池供电的方案中，往往会遇到供电不够导致MCU或者外设工作不正常的情况。PVD在这个时候就可以派上用场了。<br>PVD的使用按照数据手册上的说明，就是首先设置PVD阈值（PVD thresholds），当MCU的VDD引脚的电压高于阈值时，则PVD output=1，当VDD电压低于阈值时，PVD output=0，如下图所示：</p>
<p><img src="../../../../uploads/PVD_images/PVD_1.jpg" alt=""></p>
<p>其中PVD output的结果可以再在存器中查看到 </p>
<p><img src="../../../../uploads/PVD_images/PVD_4.jpg" alt=""><br><img src="../../../../uploads/PVD_images/PVD_3.jpg" alt=""></p>
<p>关于PVD的阈值的设定共有两种方式：</p>
<ul>
<li>固定阈值(1.9V 2.1V 2.3V 2.5V 2.7V 2.9V 3.1V)</li>
<li>与引脚比较（PB7）</li>
</ul>
<p>在实际使用的过程中,PVD可以用查询挥着中断的方式来工作。</p>
<p>在测试的例程中，我配置PVD工作方式为中断上升下降沿触发，当VDD高于预设PVD阈值或者低于阈值而产生边沿触发时，都会形成一次PVD中断，然后读取PWR_CSR的PVDO标志位检查是低电压提醒还是高电压提醒，以此来达到监控MCU供电情况的目的。</p>
<p>注意：当使用PVD功能检测低电压时，VDD电压刚刚小于阈值时并不会直接产生PVD中断，只有当VDD电压小于（阈值-50MV）时，才会产生中断。</p>
<p>如果有什么疑问或者错误欢迎大家指正，email:454626653@qq.com</p>
]]></content>
    </entry>
    
  
  
</search>
